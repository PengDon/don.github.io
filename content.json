{"meta":{"title":"pengdon","subtitle":null,"description":null,"author":"don","url":"https://pengdon.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-28T01:37:40.732Z","updated":"2020-04-28T01:37:40.732Z","comments":false,"path":"about/index.html","permalink":"https://pengdon.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"tags","date":"2019-11-14T11:39:03.000Z","updated":"2020-04-27T01:23:56.958Z","comments":false,"path":"tags/index.html","permalink":"https://pengdon.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-28T01:37:40.736Z","updated":"2020-04-28T01:37:40.736Z","comments":false,"path":"repository/index.html","permalink":"https://pengdon.github.io/repository/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-11-14T11:31:42.000Z","updated":"2020-04-27T01:23:56.956Z","comments":false,"path":"categories/index.html","permalink":"https://pengdon.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"python常用命令","slug":"python5","date":"2020-06-22T06:36:50.000Z","updated":"2020-06-22T06:52:21.304Z","comments":true,"path":"2020/06/22/python5/","link":"","permalink":"https://pengdon.github.io/2020/06/22/python5/","excerpt":"","text":"前提 python3.8 win10 64 vscode pip常用命令 123456789101112131415161718192021222324252627282930313233343536# 查看版本pip -V# 安装模块pip install 模块名称# 卸载模块pip uninstall 模块名称# 查看模块是否已安装pip show 模块名# 升级模块pip install --upgrade 模块名称# 升级pippip install --upgrade pip# 列出已安装包pip list# 显示模块所在目录pip show -f 模块名称# 搜索模块pip search 模块名称# 查询可升级包pip list -o# 下载模块而不安装pip install -d 模块名称# 打包pip wheel 模块名称# 更换国内pypi镜像## 国内镜像阿里：https://mirrors.aliyun.com/pypi/simple中国科学技术大学：http://pypi.mirrors.ustc.edu.cn/simple/## 指定单次安装源pip install -i 模块名 https://mirrors.aliyun.com/pypi/simple## 指定全局安装源配置文件路径：%HOME%\\pip\\pip.ini文件内容：[global]timeout = 6000 index-url = https://mirrors.aliyun.com/pypi/simple","categories":[{"name":"python","slug":"python","permalink":"https://pengdon.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pengdon.github.io/tags/python/"}]},{"title":"python处理excel文件","slug":"python4","date":"2020-06-22T06:29:36.000Z","updated":"2020-06-23T02:40:04.514Z","comments":true,"path":"2020/06/22/python4/","link":"","permalink":"https://pengdon.github.io/2020/06/22/python4/","excerpt":"","text":"前提 python3.8 win10 64 vscode 操作excel 说明：整个excel文件称为工作簿，工作簿中的每个页称为工作表，工作表又由单元格组成 xlrd模块读取excel文件(xlrd模块既可读取xls文件也可读取xlsx文件) xlwt模块写入excel文件(xlwt模块只能写xls文件，不能写xlsx文件) 1234567# 检查模块是否安装pip show xlrdpip show xlwt# 安装模块pip install xlrdpip install xlwt xlrd模块读取excel文件 年报excel（annals.xls）内容如下： 年份 季度 营销额 增长 2016 一季度 2000 10.20% 2017 二季度 3000 34.00% 2018 三季度 2877 28.30% 2019 四季度 3882 42.00% xlrd怎么用 12345678910111213141516171819202122# 引入模块 import xlrd# 获取工作簿 annals = xlrd.open_workbook('excel文件名.xls')# 获取所有工作表名称,结果为列表 names = annals.sheet_names()# 根据索引或者名称获取工作表对象# 索引sheet = annals.sheet_by_index(i)# 名称sheet = annals.sheet_by_name('工作表名称')# 获取工作表行数、列数# 行数rows = sheet.nrows# 列数cols = sheet.ncols# 获取工作表某一行的内容,结果为列表row = sheet.row_values(i)# 获取工作表某一列的内容,结果为列表col = sheet.col_values(i)# 获取工作表某一单元格的的内容,结果为字符串或数值cell = sheet.cell_value(m,n).value 读取年报（annals.xls） 12345678910import xlrdfrom logger import Loggingsloggings = Loggings()annals = xlrd.open_workbook('annals.xls')loggings.info(f'所有工作表名称：&#123;annals.sheet_names()&#125;')sheet = annals.sheet_by_name('Sheel')rows = sheet.nrowscols = sheet.ncolsloggings.info(f'行：&#123;rows&#125;')loggings.info(f'列：&#123;cols&#125;') xlwt怎么用 12345678910# 引入模块import xlwt# 创建工作簿,如果写入中文为乱码，可添加参数encoding = 'utf-8'book = wlwt.Wortbook()# 创建工作表sheet = book.add_sheet('工作表名称')# 向单元格写入内容sheet.write(行下标,列下标,值)# 保存工作簿，默认保存在py文件相同路径下，如果该路径下有相同文件，会被新创建的文件覆盖book.save('excel文件名称') 写入数据 逐步插入数据 123456import xlwtbook = xlwt.Workbook()sheet = book.add_sheet('Sheel')sheet.write(0,0,'类型')sheet.write(0,1,'书名')book.save('book.xls') book.xls内容如下： 类型 内容 按行插入 123456789101112131415import xlwtbook = xlwt.Workbook()sheet = book.add_sheet('Sheel')titles = ['类型','书名']types = ['java','算法']booknames = ['think in java','计算机算法3']for i in range(0,len(titles)): sheet.write(0,i,titles[i])for i in range(0,len(types)): sheet.write(i+1,0,types[i])for i in range(0,len(booknames)): sheet.write(i+1,1,booknames[i])book.save('book.xls') book.xls内容如下： 类型 内容 java think in java 算法 计算机算法3 自定义字体样式的excel表 12345678910111213import xlwtbook = xlwt.Workbook(encoding='utf-8')sheet = book.add_sheet('shee1')style = xlwt.XFStyle() # 初始化样式font = xlwt.Font() # 初始化字体font.name = 'Times New Roman' # 使用字体的名称font.bold = True # 字体加粗font.underline = True # 字体加下划线font.italic = True # 斜体字style.font = font # 设定样式使用的字体sheet.write(0,0, 'unformated') # 不带样式的表单内容sheet.write(0,1, 'formated', style) # 带样式的表单内容book.save('book.xls') 设置单元格的宽度 12345book = xlwt.Workbook(encoding='utf-8')sheet = book.add_sheet('shee1')sheet.write(0, 0, '测试用例')sheet.col(0).width = 3333 # 设置表单：sheet1 的第一列所有单元格的宽度book.save('book.xls') 输入一个日期到单元格 12345678910import datetimebook = xlwt.Workbook()sheet = book.add_sheet('sheet1')style = xlwt.XFStyle() # 凡是设置表格属性，都需要初始化一个样式style.num_format_str = 'M/D/YY' # 设置当前表格的日期格式，以下为其他可选的格式# D: 表示日期， M：表示月份，Y：表示年，h：表示小时，m：表示分钟，s：表示秒# Other options: D-MMM-YY, D-MMM, MMM-YY, h:mm, h:mm:ss, h:mm, h:mm:ss, M/D/YY h:mm, mm:ss, [h]:mm:ss, mm:ss.0sheet.col(1).width = 3333 # 设定日期表格宽度sheet.write(0,1, datetime.datetime.today(), style) # 设定当前表格日期采用style样式显示book.save('book.xls') 向表格添加一个公式 1234567book = xlwt.Workbook()sheet = book.add_sheet('sheet')sheet.write(0, 0, 5)sheet.write(0, 1, 2)sheet.write(1, 0, xlwt.Formula(('A1*B1'))) # 实现第一行第一个字段和第二个字段值相乘，写入到第二行第一个表格内sheet.write(1, 1, xlwt.Formula('SUM(A1,B1)')) # 实现第一行第一个字段和第二个字段值相加，写入到第二行第二个表格内book.save('book.xls') 向一个表格添加一个超链接 1234book = xlwt.Workbook()sheet = book.add_sheet('sheet_link')sheet.write(0, 1, xlwt.Formula('HYPERLINK(\"http://www.baidu.com\";\"baidu\")')) # 在表格里创建一个超链接，名称为：baidubook.save('book.xls') 合并列和行 12345678910# 关于write_merge(x,m,y,n)参数说明：x 表示行数，m表示跨行个数， y表示列， n表示跨列个数，行和列的开始计数都为0book = xlwt.Workbook()sheet = book.add_sheet('sheet')sheet.write_merge(0, 0, 1, 3, 'First merge') font = xlwt.Font()font.bold = Truestyle = xlwt.XFStyle()style.font = fontsheet.write_merge(1, 2, 0, 3, 'second merge', style)book.save('book.xls') 设置单元格内容的对其方式 123456789workbook = xlwt.Workbook()worksheet = workbook.add_sheet('My Sheet')alignment = xlwt.Alignment() # Create Alignmentalignment.horz = xlwt.Alignment.HORZ_CENTER # May be: HORZ_GENERAL, HORZ_LEFT, HORZ_CENTER, HORZ_RIGHT, HORZ_FILLED, HORZ_JUSTIFIED, HORZ_CENTER_ACROSS_SEL, HORZ_DISTRIBUTEDalignment.vert = xlwt.Alignment.VERT_CENTER # May be: VERT_TOP, VERT_CENTER, VERT_BOTTOM, VERT_JUSTIFIED, VERT_DISTRIBUTEDstyle = xlwt.XFStyle() # Create Stylestyle.alignment = alignment # Add Alignment to Styleworksheet.write(0, 0, 'Cell Contents', style)workbook.save('book.xls') 为单元格设置背景色 12345678910book = xlwt.Workbook()sheet = book.add_sheet('sheet')pattern = xlwt.Pattern() # 初始化一个图案pattern.pattern = xlwt.Pattern.SOLID_PATTERN # 可选：NO_PATTERN, SOLID_PATTERN, or 0x00 through 0x12pattern.pattern_fore_colour = 5 # 背景颜色为黄色 # 可选： 0 = Black, 1 = White, 2 = Red, 3 = Green, 4 = Blue, 5 = Yellow, 6 = Magenta, 7 = Cyan, 16 = Maroon, 17 = Dark Green, 18 = Dark Blue, 19 = Dark Yellow , almost brown), 20 = Dark Magenta, 21 = Teal, 22 = Light Gray, 23 = Dark Gray, the list goes on...style = xlwt.XFStyle()style.pattern = pattern # 添加样式sheet.write(0, 0, 'Cell content', style)book.save('book.xls') 处理xlsx文件 openpyxl模块可实现对excel文件的读、写和修改，只能处理xlsx文件，不能处理xls文件 openpyxl读取excel文件 12345678910111213141516171819# 引入模块import openpyxl# 获取工作簿对象book = openpyxl.load_workbook('excel文件名称')# 获取所有工作表名称names = book.sheetnames# 获取工作表对象sheet = book.worksheets[i]sheet2 = book['工作表名称']sheet3 = book[book.sheetnames[i]]# 获取工作表名称title = sheet1.title# 获取工作表行数rows = sheet1.max_row# 获取工作表列数cols = sheet1.max_column# 获取某一单元格内容，x/y 例如： 0,0 1,2 ，单元格 A1 B1cell = sheet.cell(x,y).valuecell = sheet['单元格'].value openpyxl写excel文件 12345678910# 引入模块import openpyxl# 创建工作簿book = openpyxl.Workbook()# 创建工作表，0表示创建的工作表在工作薄最前面sheet = book.create_sheet('工作表名称',0)# 向单元格写入内容 sheet.cell(x,y,'内容1')# 保存工作簿book.save('excel文件名称') openpyxl修改excel文件 123456789101112131415161718192021# 引入模块import openpyxl# 获取工作簿对象book = openpyxl.load_workbook('excel文件名称')# 获取所有工作表名称names = book.sheetnames# 获取工作表对象sheet = book.worksheets[i]# 在某行前插入sheet.insert_rows(x)# 在某列前插入sheet.insert_cols(y)# 删除指定行sheet.delete_rows(x)# 删除指定列sheet.delete_cols(y)# 修改单元格内容sheet.cell(x,y) = '内容'sheet['单元格'] = '内容'# 在最后追加行sheet.append([x,y,'内容']) 参考 python操作excel xlrd xlrd api openpyxl api","categories":[{"name":"python","slug":"python","permalink":"https://pengdon.github.io/categories/python/"}],"tags":[{"name":"python excel","slug":"python-excel","permalink":"https://pengdon.github.io/tags/python-excel/"}]},{"title":"python 日志工具类","slug":"python3","date":"2020-06-19T07:51:49.000Z","updated":"2020-06-19T07:59:31.452Z","comments":true,"path":"2020/06/19/python3/","link":"","permalink":"https://pengdon.github.io/2020/06/19/python3/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142'''@Description: 日志工具类'''import timefrom loguru import loggerfrom pathlib import Pathproject_path = Path.cwd()log_path = Path(project_path, \"logs\")t = time.strftime(\"%Y_%m_%d\")class Loggings(object): __instance = None logger.add(f\"&#123;log_path&#125;/operation_log_&#123;t&#125;.log\",format=\"&#123;time:YYYY-MM-DD HH:mm:ss&#125; | &#123;level&#125; | &#123;message&#125;\", rotation=\"50MB\", encoding=\"utf-8\", enqueue=True, retention=\"10 days\") def __new__(cls, *args, **kwargs): if not cls.__instance: cls.__instance = super(Loggings, cls).__new__(cls, *args, **kwargs) return cls.__instance def info(self, msg): return logger.info(msg) def debug(self, msg): return logger.debug(msg) def warning(self, msg): return logger.warning(msg) def error(self, msg): return logger.error(msg)# 测试,只有在当前文件直接执行时，才会执行以下代码loggings = Loggings()if __name__ == '__main__': loggings.info(\"info 测试\") loggings.debug(\"debug 测试\") loggings.warning(\"warn 测试\") loggings.error(\"error 测试\")","categories":[{"name":"python","slug":"python","permalink":"https://pengdon.github.io/categories/python/"}],"tags":[{"name":"python io","slug":"python-io","permalink":"https://pengdon.github.io/tags/python-io/"}]},{"title":"python mysql数据库操作封装","slug":"python2","date":"2020-06-18T03:13:36.000Z","updated":"2020-06-22T06:36:18.031Z","comments":true,"path":"2020/06/18/python2/","link":"","permalink":"https://pengdon.github.io/2020/06/18/python2/","excerpt":"","text":"前提 python3.8 win10 64 vscode 思路 1、数据库场景：连接数据、操作数据库、关闭连接 1、与python版本对应的mysql模块下载 MySQLdb 打开https://www.lfd.uci.edu/~gohlke/pythonlibs/ 搜索关键字“Mysqlclient”，下载对应的模块，eg: mysqlclient‑1.4.6‑cp38‑cp38‑win_amd64.whl 打开命令行，执行：pip install 刚才下载的模块，进行安装 在命令行执行：pip list ，查看是否安装成功 mysql工具类(简易版) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import MySQLdbfrom logger import Loggingsloggings = Loggings()class DB: def __init__(self): super(DB, self).__init__() self.conn = None self.cursor = None # 开启连接 def connect(self): try: loggings.info(\"数据库连接中...\") # 写法一 # self.conn = MySQLdb.Connect(\"localhost\",\"root\",\"usbw\",\"egg\") # 写法二 self.conn = MySQLdb.connect(host=\"localhost\", user=\"root\", passwd=\"usbw\", db=\"egg\", charset=\"utf8\") loggings.info(\"数据库连接已开启\") except Exception as err: loggings.error(\"数据库连接失败\") loggings.error(Exception) loggings.error(err) self.cursor = self.conn.cursor() # 关闭连接 def close(self): # 如果连接已打开，则关闭；否则没有操作 if self.conn and self.cursor: loggings.info(\"关闭数据库连接\") self.cursor.close() self.conn.close() return True # 插入单条数据 def insert(self, sql, param): self.connect() loggings.info(f'执行的sql代码：&#123;sql&#125;') loggings.info(f'相关参数：&#123;param&#125;') try: self.cursor.execute(sql, param) self.conn.commit() except Exception as err: loggings.error(\"数据插入失败\") loggings.error(Exception) loggings.error(err) return False return True self.close() # 插入多条数据 def insertMuti(self, sql, param): self.connect() loggings.info(f'执行的sql代码：&#123;sql&#125;') loggings.info(f'相关参数：&#123;param&#125;') try: self.cursor.executemany(sql, param) self.conn.commit() except Exception as err: loggings.error(\"数据插入失败\") loggings.error(Exception) loggings.error(err) return False return True self.close() # 查询所有 def queryAll(self, sql): self.connect() loggings.info(f'执行的sql代码：&#123;sql&#125;') try: self.cursor.execute(sql) return self.cursor.fetchall() except Exception as err: loggings.error(\"查询失败\") loggings.error(Exception) loggings.error(err) self.close() # 查询一条数据 def queryOne(self, sql): self.connect() loggings.info(f'执行的sql代码：&#123;sql&#125;') try: self.cursor.execute(sql) return self.cursor.fetchone() except Exception as err: loggings.error(\"查询失败\") loggings.error(Exception) loggings.error(err) self.close() # 更新数据 def update(self, sql, param): self.connect() loggings.info(f'执行的sql代码：&#123;sql&#125;') loggings.info(f'相关参数：&#123;param&#125;') try: self.cursor.execute(sql, param) except Exception as err: loggings.error(\"数据更新失败\") loggings.error(Exception) loggings.error(err) return False return True self.close() # 删除数据 def delete(self, sql, param): self.connect() loggings.info(f'执行的sql代码：&#123;sql&#125;') loggings.info(f'相关参数：&#123;param&#125;') try: self.cursor.execute(sql, param) except Exception as err: loggings.error(\"数据删除失败\") loggings.error(Exception) loggings.error(err) return False return True self.close()# # 测试,只有在当前文件直接执行时，才会执行以下代码db = DB()# if __name__ == '__main__':# rst = db.queryAll('select * from users')# loggings.info(f'查詢結果：&#123;rst&#125;') # db.delete('delete from users where name=%s', ('李逵')) # db.insert('insert into users(name,roleId) values (%s,%s)', ('李逵', 3))","categories":[{"name":"python","slug":"python","permalink":"https://pengdon.github.io/categories/python/"}],"tags":[{"name":"python mysql","slug":"python-mysql","permalink":"https://pengdon.github.io/tags/python-mysql/"}]},{"title":"python记录1","slug":"python","date":"2020-06-18T02:35:45.000Z","updated":"2020-06-18T03:18:54.387Z","comments":true,"path":"2020/06/18/python/","link":"","permalink":"https://pengdon.github.io/2020/06/18/python/","excerpt":"","text":"Python简介 Python（英国发音：/ˈpaɪθən/美国发音：/ˈpaɪθɑːn/），是一种面向对象的解释型计算机程序设计语言，由荷兰人GuidovanRossum于1989年发明，第一个公开发行版发行于1991年。 Python是纯粹的自由软件，源代码和解释器CPython遵循GPL（GNUGeneralPublicLicense）协议。Python语法简洁清晰，特色之一是强制用空白符（whitespace）作为语句缩进。 Python特点 Python使用C语言开发，但是Python不再有C语言中的指针等复杂的数据类型。 Python具有很强的面向对象特性，而且简化了面向对象的实现。它消除了保护类型、抽象类、接口等面向对象的元素。 Python代码块使用空格或制表符缩进的方式分隔代码。 Python仅有31个保留字，而且没有分号、begin、end等标记。 Python是强类型语言，变量创建后会对应一种数据类型，出现在统一表达式中的不同类型的变量需要做类型转换。 python开发环境搭建 python官网：https://www.python.org 到官网下载对应系统配置的安装包，以windows为例：https://www.python.org/downloads/windows/ 检查python版本：python -V 检查pip版本： pip -V Python应用以及场景 系统编程：提供API（ApplicationProgrammingInterface应用程序编程接口），能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。 图形处理：有PIL、Tkinter等图形库支持，能方便进行图形处理。 数学处理：NumPy扩展提供大量与许多标准数学库的接口。 文本处理：python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。 数据库编程：程序员可通过遵循PythonDB-API（数据库应用程序编程接口）规范的模块与MicrosoftSQLServer，Oracle，Sybase，DB2，MySQL、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的SQL环境。 网络编程：提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。很多大规模软件开发计划例如Zope，Mnet及BitTorrent.Google都在广泛地使用它。 多媒体应用：Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。 pymo引擎：PYMO全称为pythonmemoriesoff，是一款运行于SymbianS60V3，Symbian3，S60V5，Symbian3，Android系统上的AVG游戏引擎。因其基于python2.0平台开发，并且适用于创建秋之回忆（memoriesoff）风格的AVG游戏，故命名为PYMO。 黑客编程：python有一个hack的库，内置了你熟悉的或不熟悉的函数，但是缺少成就感。 网络爬虫：也称网络蜘蛛，是大数据行业获取数据的核心工具。没有网络爬虫自动地、不分昼夜地、高智能地在互联网上爬取免费的数据，那些大数据相关的公司恐怕要少四分之三。能够编写网络爬虫的编程语言有不少，但Python绝对是其中的主流之一，其Scripy爬虫框架应用非常广泛。 科学计算：NumPy，SciPy，Matplotlib可以让Python程序员编写科学计算程序。 桌面软件：PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。 服务器软件（网络软件）： Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议（包含客户端和服务器），并且提供了多种工具，被广泛用于编写高性能的服务器软件。 游戏：很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型。 自动化运维：这几乎是Python应用的自留地，作为运维工程师首选的编程语言，Python在自动化运维方面已经深入人心，比如Saltstack和Ansible都是大名鼎鼎的自动化平台。 云计算：开源云计算解决方案OpenStack就是基于Python开发的，搞云计算的同学都懂的。 WEB开发：基于Python的Web开发框架不要太多，比如耳熟能详的Django，还有Tornado，Flask。其中的Python+Django架构，应用范围非常广，开发速度非常快，学习门槛也很低，能够帮助你快速的搭建起可用的WEB服务。 数据分析： 在大量数据的基础上，结合科学计算、机器学习等技术，对数据进行清洗、去重、规格化和针对性的分析是大数据行业的基石。Python是数据分析的主流语言之一。 人工智能：Python在人工智能大范畴领域内的机器学习、神经网络、深度学习等方面都是主流的编程语言，得到广泛的支持和应用。 参考资料 python文档 Python语言规范","categories":[{"name":"python","slug":"python","permalink":"https://pengdon.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://pengdon.github.io/tags/python/"}]},{"title":"Axios 记录","slug":"axios","date":"2020-05-21T07:04:45.000Z","updated":"2020-05-21T09:37:36.069Z","comments":true,"path":"2020/05/21/axios/","link":"","permalink":"https://pengdon.github.io/2020/05/21/axios/","excerpt":"","text":"简写说明 -S --&gt; --save -D --&gt; --save-dev 插件安装 12npm install axios -Snpm install qs -S 常用API axios(config) axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 处理并发请求 axios.all(iterable) axios.spread(callback) 创建实例 axios.create([config]) 请求配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应结构 12345678910111213141516&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 服务器响应的头 headers: &#123;&#125;, // `config` 是为请求提供的配置信息 config: &#123;&#125;&#125; 全局配置 123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义配置 1234567// 创建实例时设置配置的默认值const instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序 配置会以一个优先顺序进行合并。这个顺序是：在lib/defaults.js找到库的默认值，然后是实例的defaults属性，最后是请求的config参数。后者将优先于前者。这里是一个例子： 12345678910// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是0var instance= axios.create();// 覆写库的超时默认值// 现在，在超时前，所有的请求都会等待2.5秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/url',&#123; timeout:5000&#125;) 拦截器 12345678910111213141516171819202122232425// 请求拦截器axios.interceptors.request.use(function(config)&#123; // 在发送请求前做些什么 return config; &#125;,functoin(err)&#123; // 对请求错误做些什么 return Promise.reject(err);&#125;);// 响应拦截器axios.interceptors.response.use(function(res)&#123; // 对响应数据做点什么 return res; &#125;,function(err)&#123; //对响应错误做点什么 return Promise.reject(err) &#125;)// 移除拦截器var myInterceptor = axios.ineterceptors.request.use(function()&#123;&#125;);axios.interceptors.request.eject(myInterceptor);// 自定义axios实例添加拦截器var instance = axios.create();instance.interceptors.request.use(function()&#123;&#125;); 错误处理 1234567891011121314151617181920212223axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 发出请求后，服务器用状态代码响应 // 不在2xx的范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if (error.request) &#123; // 发出了请求，但没有收到答复 console.log(error.request); &#125; else &#123; console.log('Error', error.message); &#125; console.log(error.config); &#125;);// 自定义错误码axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 仅当状态码大于或等于500时才拒绝 &#125;&#125;) 取消 使用cancel token取消请求。可以使用CancelToken.source工厂方法创建cancel token，像这样： 12345678910111213var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken:source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message) &#125;else&#123; // 处理错误 &#125;&#125;);// 取消请求（message参数是可选的）source.cancel('sadsad') 还可以通过传递一个executor函数到CancelToken的构造函数来创建cancle token： 12345678910var CancelToken = axios.CancelToken;var cancel;axios.get('/user/12345',&#123; cancelToken:new CnacelToken(function executor(c)&#123; //executor函数接受一个cancel函数作为参数 cancel = c; &#125;)&#125;);//取消请求cancel(); 参考 Axios 网络文档 Axios npm地址 Axios github地址 qs","categories":[{"name":"Axios","slug":"Axios","permalink":"https://pengdon.github.io/categories/Axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"https://pengdon.github.io/tags/axios/"}]},{"title":"vueTypescript 简单实现2","slug":"vueTypescript2","date":"2020-05-09T08:43:39.000Z","updated":"2020-05-09T08:46:36.945Z","comments":true,"path":"2020/05/09/vueTypescript2/","link":"","permalink":"https://pengdon.github.io/2020/05/09/vueTypescript2/","excerpt":"","text":"注意 接着“vue typescript 简单实现”的基础上添加 typescript 支持 新增说明 1、添加 eslint 支持 eslint@6.5.1、@typescript-eslint/parser、@typescript-eslint/eslint-plugin 2、用来检测和规范 Vue 代码的风格 eslint-plugin-vue 3、用来做格式化工具配合我们的 ESLint 可以更大的发挥作用 prettier、eslint-config-prettier、eslint-plugin-prettier 依赖插件安装 123npm install eslint@6.5.1 @typescript-eslint/parser @typescript-eslint/eslint-plugin -Dnpm install eslint-plugin-vue -Dnpm install prettier eslint-config-prettier eslint-plugin-prettier -D","categories":[{"name":"Vue-Typescript","slug":"Vue-Typescript","permalink":"https://pengdon.github.io/categories/Vue-Typescript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"typescript","slug":"typescript","permalink":"https://pengdon.github.io/tags/typescript/"}]},{"title":"vue typescript 简单实现","slug":"vueTypescript","date":"2020-05-09T06:46:32.000Z","updated":"2020-05-09T07:42:00.294Z","comments":true,"path":"2020/05/09/vueTypescript/","link":"","permalink":"https://pengdon.github.io/2020/05/09/vueTypescript/","excerpt":"","text":"注意 接着“vue webpack 从零开始搭建项目框架1”的基础上添加typescript支持 回顾vue webpack 从零开始搭建项目框架1 目录结构 12345678-xxx |--.gitignore # git忽略提交 |--app.js # 入口文件 |--App.vue # 需要渲染展示的内容 |--index.html # 模板插槽 |--pageage-lock.json # 锁定所有模块的版本号 |--pageage.json # 记录你项目中所需要的所有模块 |--webpack.config.js # webpack配置文件 新增说明 名称 描述 ts-loader TypeScript 为 Webpack 提供了 ts-loader，其实就是为了让webpack识别 .ts .tsx文件 tslint、tslint-loader 约束代码格式 vue-class-component 强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件 vue-property-decorator 在 vue-class-component 上增强更多的结合 Vue 特性的装饰器 安装依赖 12npm install typescript ts-loader tslint tslint-loader -Dnpm install vue-property-decorator vue-class-component -S 代码片段 1、修改webpack.config.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.join(__dirname, './app.ts'), mode: 'development', output: &#123; filename: 'index.js', path: path.join(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /.vue$/, loader: 'vue-loader' &#125;, &#123; test: /\\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader' &#125;, &#123; test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125; &#125; ] &#125;, resolve: &#123; extensions: ['.js','.ts', '.json', '.css', '.vue'], modules: [\"node_modules\", path.resolve(__dirname, 'app')] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'index.html', // 模版路径 filename: 'index.html', // 生成的文件名称 inject: 'body' // 指定插入的&lt;script&gt;标签在body底部 &#125;), new VueLoaderPlugin() ], devServer: &#123; host: '127.0.0.1', port: '8899', // contentBase:__dirname, compress: true, // enable gzip compression hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin disableHostCheck: true &#125;&#125; 2、添加tsconfig.json文件 123456789101112131415161718192021&#123; \"exclude\": [ \"node_modules\" ], \"compilerOptions\": &#123; \"allowSyntheticDefaultImports\": true, \"experimentalDecorators\": true, \"allowJs\": true, \"module\": \"esnext\", \"target\": \"es5\", \"moduleResolution\": \"node\", \"isolatedModules\": true, \"lib\": [ \"dom\", \"es5\", \"es2015.promise\" ], \"sourceMap\": true, \"pretty\": true &#125;&#125; 3、让ts识别*.vue文件,在根目录新建vue.d.ts 1234declare module \"*.vue\" &#123; import Vue from \"vue\"; export default Vue;&#125; 4、修改App.vue文件 123456789101112&lt;template&gt; &lt;div&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import Vue from 'vue'import Component from 'vue-class-component'@Componentexport default class App extends Vue &#123; msg:string = 'vue typescript'&#125;&lt;/script&gt; 5、执行命令会自动打开浏览器，查看是否正常显示出App.vue里面的内容 1234# 开发环境npm run dev# 生产环境npm run build 6、完整的目录结构 12345678910-xxx |--.gitignore # git忽略提交 |--app.ts # 入口文件 |--App.vue # 需要渲染展示的内容 |--index.html # 模板插槽 |--pageage-lock.json # 锁定所有模块的版本号 |--pageage.json # 记录你项目中所需要的所有模块 |--vue.d.ts # 类型定义文件 |--tsconfig.json # typescript配置文件 |--webpack.config.js # webpack配置文件 7、tsconfg.json配置文件说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 编译选项 \"compilerOptions\": &#123; // 输出目录 \"outDir\": \"./output\", // 是否包含可以用于 debug 的 sourceMap \"sourceMap\": true, // 以严格模式解析 \"strict\": true, // 采用的模块系统 \"module\": \"esnext\", // 如何处理模块 \"moduleResolution\": \"node\", // 编译输出目标 ES 版本 \"target\": \"es5\", // 允许从没有设置默认导出的模块中默认导入 \"allowSyntheticDefaultImports\": true, // 将每个文件作为单独的模块 \"isolatedModules\": false, // 启用装饰器 \"experimentalDecorators\": true, // 启用设计类型元数据（用于反射） \"emitDecoratorMetadata\": true, // 在表达式和声明上有隐含的any类型时报错 \"noImplicitAny\": false, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 \"importHelpers\": true, // 编译过程中打印文件名 \"listFiles\": true, // 移除注释 \"removeComments\": true, \"suppressImplicitAnyIndexErrors\": true, // 允许编译javascript文件 \"allowJs\": true, // 解析非相对模块名的基准目录 \"baseUrl\": \"./\", // 指定特殊模块的路径 \"paths\": &#123; \"jquery\": [ \"node_modules/jquery/dist/jquery\" ] &#125;, // 编译过程中需要引入的库文件的列表 \"lib\": [ \"dom\", \"es2015\", \"es2015.promise\" ] &#125;&#125; 参考 Vue Typescript Typescript","categories":[{"name":"Vue-Typescript","slug":"Vue-Typescript","permalink":"https://pengdon.github.io/categories/Vue-Typescript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"typescript","slug":"typescript","permalink":"https://pengdon.github.io/tags/typescript/"}]},{"title":"vue webpack 从零开始搭建项目框架3","slug":"vueWebpack3","date":"2020-05-07T07:01:24.000Z","updated":"2020-05-08T03:06:21.615Z","comments":true,"path":"2020/05/07/vueWebpack3/","link":"","permalink":"https://pengdon.github.io/2020/05/07/vueWebpack3/","excerpt":"","text":"注意 接着“vue webpack 从零开始搭建项目框架2”继续扩展 1、添加路由支持(vue-router) 2、添加状态管理支持(vuex) 安装前提 node10^ npm6^ vue2.6^ webpack^4 简写说明 -S --&gt; --save -D --&gt; --save-dev 新增功能 添加路由支持 1npm install vue-router -S 添加vuex支持 1npm install vuex -S 添加路由代码片段 1、修改public目录下的index.html文件 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;router-view/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、删除App.vue 3、在src目录新建router文件夹，router文件夹下新建index.js文件 1234567891011121314151617181920212223// src/router/index.jsimport Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter)const A = &#123;template: '&lt;div&gt;aaa&lt;/div&gt;'&#125;const B = &#123;template: '&lt;div&gt;bbb&lt;/div&gt;'&#125;const routes = [ &#123; path: '/', component: A &#125;, &#123; path: '/b', component: B &#125;]export default new VueRouter(&#123; routes&#125;) 4、修改app.js 1234567import Vue from 'vue'import router from './router'import './assets/css/index.css'new Vue(&#123; router,&#125;).$mount('#app') 5、执行代码就就可以看到效果了 添加状态管理代码片段 1、在src目录下新建store文件夹，在store目录新建index.js文件 123456789101112131415import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 2、修改app.js文件 123456789import Vue from 'vue'import store from './store'import router from './router'import './assets/css/index.css'new Vue(&#123; store, router,&#125;).$mount('#app') 3、在src目录下新建views文件夹，在views目录下新建Count.vue 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;button @click=\"increment\"&gt;添加&lt;/button&gt; &#123;&#123;this.$store.state.count&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; increment() &#123; this.$store.commit('increment') console.log(this.$store.state.count) &#125; &#125;&#125;&lt;/script&gt; 4、修改路由配置 1234567891011121314151617181920212223242526import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter)const A = &#123;template: '&lt;div&gt;aaa&lt;/div&gt;'&#125;const B = &#123;template: '&lt;div&gt;bbb&lt;/div&gt;'&#125;const routes = [ &#123; path: '/', component: A &#125;, &#123; path: '/b', component: B &#125;, &#123; path: '/count', component: () =&gt; import('../views/Count.vue') &#125;]export default new VueRouter(&#123; routes&#125;) 5、执行代码就就可以看到效果了 参考 Vue Router Vue Vuex","categories":[{"name":"Vue-Webpack","slug":"Vue-Webpack","permalink":"https://pengdon.github.io/categories/Vue-Webpack/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://pengdon.github.io/tags/webpack/"}]},{"title":"vue webpack 从零开始搭建项目框架2","slug":"vueWebapck2","date":"2020-04-30T02:13:10.000Z","updated":"2020-05-08T03:04:48.490Z","comments":true,"path":"2020/04/30/vueWebapck2/","link":"","permalink":"https://pengdon.github.io/2020/04/30/vueWebapck2/","excerpt":"","text":"注意 接着“vue webpack 从零开始搭建项目框架1”继续扩展 1、增加了目录结构 2、增加了处理css/js/字体/图片资源的加载器 安装前提 node10^ npm6^ vue2.6^ webpack^4 简写说明 -S --&gt; --save -D --&gt; --save-dev 回顾 上一章搭建了最基本的结构，这章会逐步完善结构 1、上一章代码目录结构 12345678-xxx |--.gitignore # git忽略提交 |--app.js # 入口文件 |--App.vue # 需要渲染展示的内容 |--index.html # 模板插槽 |--pageage-lock.json # 锁定所有模块的版本号 |--pageage.json # 记录你项目中所需要的所有模块 |--webpack.config.js # webpack配置文件 2、准备改造成以下目录 12345678910-xxx |--.gitignore # git忽略提交 |--public # 用来存放公共静态资源 |--index.html # 模板插槽 |--src # 主要存放开发文件 |--app.js # 入口文件 |--App.vue # 需要渲染展示的内容 |--pageage-lock.json # 锁定所有模块的版本号 |--pageage.json # 记录你项目中所需要的所有模块 |--webpack.config.js # webpack配置文件 3、修改webpack.config.js配置文件 12345678910111213141516171819202122232425262728293031323334353637const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.join(__dirname, './src/app.js'), mode: 'development', output: &#123; filename: 'index.js', path: path.join(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /.vue$/, loader: 'vue-loader' &#125; ] &#125;, resolve: &#123; extensions: ['.js', '.json', '.css', '.vue'], modules: [\"node_modules\", path.resolve(__dirname, 'app')] &#125;, plugins: [ new HtmlWebpackPlugin( &#123; template: './public/index.html', // 模版路径 filename: 'index.html', // 生成的文件名称 inject: 'body' // 指定插入的&lt;script&gt;标签在body底部 &#125; ), new VueLoaderPlugin() ], devServer: &#123; disableHostCheck: true &#125;&#125; 4、执行命令会自动打开浏览器，查看是否正常显示出App.vue里面的内容 1234# 开发环境npm run dev# 生产环境npm run build 准备解决的问题 1、解决加载css文件 style-loader、css-loader 2、解决js文件ES6转ES5代码兼容各个浏览器运行要求 babel-loader、@babel/core、@babel/preset-env 3、解决css浏览器兼容性，自动补全前缀 postcss-loader、autoprefixer 4、解决样式分离、提取css(webpack4) mini-css-extract-plugin 5、解决声明了很多样式，但部分样式并没有用到，造成了css冗余，配合extract-text-webpack-plugin@next使用 purifycss-webpack、purify-css 6、解决加载静态文件(如：图片、字体等) file-loader、url-loader 依赖插件安装 12npm install style-loader css-loader babel-loader @babel/core @babel/preset-env postcss-loader autoprefixer -Dnpm install mini-css-extract-plugin purifycss-webpack purify-css file-loader url-loader -D 1、变化后的webpack.config.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');const Glob = require('glob');const PurifyCssWebpack = require('purifycss-webpack');const IsProduction = process.env.NODE_ENV === 'production';module.exports = &#123; entry: path.join(__dirname, './src/app.js'), mode: 'development', // 源码映射,参考：https://webpack.docschina.org/configuration/dev-server/#devserver devtool: IsProduction ? 'source-map' : 'eval-source-map', output: &#123; filename: 'index.js', path: path.join(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader' &#125;, &#123; test: /\\.js$/, use: ['babel-loader'], include: path.resolve(__dirname, 'src'), exclude: path.resolve(__dirname, 'node_modules') &#125;, &#123; test: /\\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; // 在css-loader 之后指定1个数量的loader（即 postcss-loader）来处理import进来的资源 importLoaders: 1 &#125; &#125;, 'postcss-loader' ] &#125;, &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; // url-loader封装了file-loader // 1.文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）； // 2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader loader: 'url-loader', options: &#123; // 把小于500000B的文件打成Base64的格式。 limit: 500000 &#125; &#125; ] &#125; ] &#125;, resolve: &#123; extensions: ['.js', '.json', '.css', '.vue'], modules: [\"node_modules\", path.resolve(__dirname, 'app')] &#125;, plugins: [ new HtmlWebpackPlugin( &#123; title: 'home', template: './public/index.html', // 模版路径 filename: 'index.html', // 生成的文件名称 inject: 'body' // 指定插入的&lt;script&gt;标签在body底部 &#125; ), new VueLoaderPlugin(), new PurifyCssWebpack(&#123; paths: Glob.sync(path.join(__dirname, '*.html')) &#125;) ], devServer: &#123; disableHostCheck: true &#125;&#125; 常见问题 问题描述 npm run dev 时看到“DeprecationWarning: Tapable.plugin is deprecated. Use new API on .hooks instead” 解决方法 参考： https://webpack.docschina.org/plugins/extract-text-webpack-plugin/#src/components/Sidebar/Sidebar.jsx 和 https://webpack.docschina.org/plugins/mini-css-extract-plugin/ 问题描述 npm run dev 时看到“Replace Autoprefixer browsers option to Browserslist config. ” 解决方法 修改postcss.config.js文件 1234567891011121314// 源文件内容module.exports = &#123; plugins: &#123; 'autoprefixer': &#123; browsers: 'last 5 version' &#125; &#125;&#125;// 修改后文件内容module.exports = &#123; plugins: [ require('autoprefixer')(&#123; overrideBrowserslist: ['&gt; 0.15% in CN'] &#125;) ]&#125; 参考 webapck vue","categories":[{"name":"Vue-Webpack","slug":"Vue-Webpack","permalink":"https://pengdon.github.io/categories/Vue-Webpack/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://pengdon.github.io/tags/webpack/"}]},{"title":"vue webpack 从零开始搭建项目框架1","slug":"vueWebapck","date":"2020-04-29T09:27:23.000Z","updated":"2020-04-30T08:22:14.024Z","comments":true,"path":"2020/04/29/vueWebapck/","link":"","permalink":"https://pengdon.github.io/2020/04/29/vueWebapck/","excerpt":"","text":"注意 主要实现最基础最简单的vue+webpack 安装前提 node10^ npm6^ vue2.6^ webpack^4 简写说明 -S --&gt; --save -D --&gt; --save-dev vue项目构成基本结构 1、引入vue库 2、html模板插槽，用于渲染数据 3、实例化Vue对象，用于处理数据(渲染、逻辑控制、展示、隐藏等) 例子： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 1、引入依赖库 --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2、html模板插槽 --&gt; &lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;!-- 实例化Vue对象 --&gt; script&gt; // 实例化vue对象并绑定数据 var app = new Vue(&#123; el: '#app', data: &#123; message: '页面加载于 ' + new Date().toLocaleString() &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 常用插件模块 名称 描述 npm 包管理工具，安装node的时候自动安装 vue vue模块 vue-loader vue文件加载器 vue-template-compiler 该模块可用于将 Vue 2.0 模板预编译为渲染函数（template =&gt; ast =&gt; render），以避免运行时编译开销和 CSP 限制。大都数场景下，与 vue-loader一起使用，只有在编写具有非常特定需求的构建工具时，才需要单独使用它 webpack 模块打包工具 webpack-cli 针对webpack官方提供的CLI工具 webpack-dev-server 提供了一个简单的web服务器和使用实时重新加载的能力 html-webpack-plugin 创建html入口文件，引入相关外部资源 extract-text-webpack-plugin@next 提取css样式,webpack4不再支持extract-text-webpack-plugin mini-css-extract-plugin [webpack4]将CSS提取到单独的文件中 copy-webpack-plugin 将static插件复制到dist optimize-css-assets-webpack-plugin 优化/压缩css资源 clean-webpack-plugin 自动清除生成的文件夹 style-loader 通过注入style标记将CSS添加到DOM中 css-loader 样式加载、解析css文件 file-loader 指示webpack将所需的对象作为文件发出并返回其公共URL url-loader 将图片文件转换为base64编码，减少http请求数 less-loader less文件加载。解析成css文件 postcss-loader 给不同浏览器的样式加上前缀 autoprefixer 自动补充前缀配合postcss-loader使用 postcss-url 转换url，复制资产的PostCSS插件 script-loader 在全局上下文中执行一次javascript文件，不需要解析 babel-loader 用来处理ES6语法，将其编译为浏览器可以执行的js语法 @babel/core babel核心包 @babel/preset-env ES语法分析包 开发与生产环境需要的webpack功能区别 1、开发环境(development模式) 热插拔调试 生成html模板 2、生产环境(production模式) 生成html模板 css样式提取 公共模块提取 JavaScript压缩 开始搭建一个vue+webpack简单例子 1、新建一个目录 1234567mkdir xxxcd xxx# 自定义npm init或者# 默认值npm init -y 2、创建文件 12345678910# 模板文件touch index.html# 存放需要渲染的内容touch App.vue# 入口文件touch app.js# webpack配置touch webpack.config.js# .gitignoretouch .gitignore 3、引入依赖 1npm install vue vue-loader webpack webpack-cli vue-template-compiler html-webpack-plugin webpack-dev-server -D 4、文件目录结构 12345678-xxx |--.gitignore # git忽略提交 |--app.js # 入口文件 |--App.vue # 需要渲染展示的内容 |--index.html # 模板插槽 |--pageage-lock.json # 锁定所有模块的版本号 |--pageage.json # 记录你项目中所需要的所有模块 |--webpack.config.js # webpack配置文件 5、文件内容 index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; App.vue 123&lt;template&gt; &lt;div&gt; app content &lt;/div&gt;&lt;/template&gt; app.js 123456import Vue from 'vue'import App from './App.vue'new Vue(&#123; render: (h) =&gt; h(App)&#125;).$mount('#app') webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.join(__dirname, './app.js'), mode: 'development', output: &#123; filename: 'index.js', path: path.join(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /.vue$/, loader: 'vue-loader' &#125; ] &#125;, resolve: &#123; extensions: ['.js', '.json', '.css', '.vue'], modules: [\"node_modules\", path.resolve(__dirname, 'app')] &#125;, plugins: [ new HtmlWebpackPlugin( &#123; template: 'index.html', // 模版路径 filename: 'index.html', // 生成的文件名称 inject: 'body' // 指定插入的&lt;script&gt;标签在body底部 &#125; ), new VueLoaderPlugin() ], devServer: &#123; disableHostCheck: true &#125;&#125; .gitignore 1node_modules/ package.json 1234567891011121314151617181920212223&#123; \"name\": \"xxx\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"dev\": \"webpack-dev-server --open --port 3000 --hot --inline --mode=development\", \"build\": \"webpack --progress --colors --mode=production\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"css-loader\": \"^3.5.3\", \"html-webpack-plugin\": \"^4.2.1\", \"vue\": \"^2.6.11\", \"vue-loader\": \"^15.9.1\", \"vue-template-compiler\": \"^2.6.11\", \"webpack\": \"^4.43.0\", \"webpack-cli\": \"^3.3.11\", \"webpack-dev-server\": \"^3.10.3\" &#125;&#125; 6、执行命令会自动打开浏览器，查看是否正常显示出App.vue里面的内容 1234# 开发环境npm run dev# 生产环境npm run build 参考 webapck vue","categories":[{"name":"Vue-Webpack","slug":"Vue-Webpack","permalink":"https://pengdon.github.io/categories/Vue-Webpack/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://pengdon.github.io/tags/webpack/"}]},{"title":"koa2基础","slug":"koa","date":"2020-04-29T03:11:59.000Z","updated":"2020-04-29T07:43:11.164Z","comments":true,"path":"2020/04/29/koa/","link":"","permalink":"https://pengdon.github.io/2020/04/29/koa/","excerpt":"","text":"前提 node10^ 简介 Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 安装 1npm i koa 最基本结构 123456// 1、引入koa模块依赖const Koa = require('koa')// 2、实例化koa对象const app = new Koa()// 3、监听3000端口，端口可以自定义app.listen(3000) 设置 app.env 默认是 NODE_ENV 或 “development” app.keys 签名的 cookie 密钥数组 app.proxy 当真正的代理头字段将被信任时 忽略 .subdomains 的 app.subdomainOffset 偏移量，默认为 2 app.proxyIpHeader 代理 ip 消息头, 默认为 X-Forwarded-For app.maxIpsCount 从代理 ip 消息头读取的最大 ips, 默认为 0 (代表无限) 中间件 处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能的函数，就叫做&quot;中间件&quot; 每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next 函数，就可以把执行权转交给下一个中间件。 如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。 多个中间件会形成一个栈结构，以&quot;先进后出&quot;的顺序执行。 1234567// 1、最外层的中间件首先执行// 2、调用next函数，把执行权交给下一个中间件// 3、coding...// 4、最内层的中间件最后执行// 5、执行结束后，把执行权交回上一层的中间件// 6、coding...// 7、最外层的中间件收回执行权之后，执行next函数后面的代码 常用代码片段 1、返回其他类型的内容 1234567891011121314151617181920// 声明一个main中间件const main = (async ctx) =&gt;&#123;if (ctx.accepts('json')) &#123; ctx.type = 'json'; ctx.body = &#123; data: 'json' &#125;; &#125; else if (ctx.accepts('html')) &#123; ctx.type = 'html'; ctx.body = '&lt;p&gt;html&lt;/p&gt;'; &#125; else if (ctx.accepts('xml')) &#123; ctx.type = 'xml'; ctx.body = '&lt;data&gt;xml&lt;/data&gt;'; &#125; else&#123; // 默认返回纯文本 ctx.type = 'text'; ctx.body = 'text'; &#125;;&#125;;// 直接运行页面中会显示json格式，因为我们没有设置请求头，所以每一种格式都是ok的// app.use()用来加载中间件app.use(main) 2、网页模板 12345const main = async (ctx) =&gt; &#123; ctx.type = 'html' ctx.body = fs.createReadStream('./data/index.html')&#125;app.use(main) 3、原生路由 12345678910app.use(async (ctx) =&gt; &#123; if (ctx.request.url == '/') &#123; //通过ctx.request.url获取用户请求路径 ctx.body = '&lt;h1&gt;首页&lt;/h1&gt;' &#125; else if (ctx.request.url == '/my') &#123; ctx.body = '&lt;h1&gt;联系我们&lt;/h1&gt;' &#125; else &#123; ctx.body = '&lt;h1&gt;404 not found&lt;/h1&gt;' &#125;&#125;) 4、koa-router 模块路由 12# 路由安装npm install koa-router 代码片段 123456789app.use(router.routes()).use(router.allowedMethods())// routes()返回路由器中间件，它调度与请求匹配的路由。// allowedMethods()处理的业务是当所有路由中间件执行完成之后,若ctx.status为空或者404的时候,丰富response对象的header头.router.get('/', async (ctx) =&gt; &#123; ctx.body = '&lt;h1&gt;首页&lt;/h1&gt;'&#125;)router.get('/my', async (ctx) =&gt; &#123; ctx.body = '&lt;h1&gt;个人中心&lt;/h1&gt;'&#125;) 5、静态资源(图片、字体、样式表、脚本…) 12# 路由安装npm install koa-staic 代码片段 1234const path = require('path')const serve = require('koa-static')const main = serve(path.join(__dirname))app.use(main) 6、重定向跳转 123456789101112const Router = require('koa-router')const router = new Router()app.use(router.routes()).use(router.allowedMethods())router.get('/commit', async (ctx) =&gt; &#123; // 重定向 ctx.redirect('/login')&#125;)router.get('/', async (ctx) =&gt; &#123; ctx.body = '主页'&#125;) 7、返回 500 状态码 123456const main = async (ctx) =&gt; &#123; // 这个时候你访问首页会报一个500的错误(内部服务器错误)服务器会报错 ctx.throw(500)&#125;app.use(main) 8、返回 400 状态码 12345678const main = async (ctx) =&gt; &#123; // response返回的状态码就是404 ctx.status = 404 // 让页面中显示该内容，服务器不不报错 ctx.body = 'Page Not Found'&#125;app.use(main) 9、处理错误的中间件 123456789101112131415161718192021const handler = async (ctx, next) =&gt; &#123; try &#123; // 执行下个中间件 await next() &#125; catch (err) &#123; // 如果main中间件是有问题的会走这里 ctx.status = err.statusCode || err.status || 500 ctx.body = &#123; // 把错误信息返回到页面 message: err.message, &#125; &#125;&#125;const main = async (ctx) =&gt; &#123; // 如果这里是没有问题的就正常执行，如果有问题会走catach ctx.throw(500)&#125;app.use(handler)app.use(main) 10、errors 事件监听 123456789const main = (ctx) =&gt; &#123; ctx.throw(500)&#125;app.on('error', (err, ctx) =&gt; &#123; // 如果有报错的话会走这里 console.error('server error', err) //err是错误源头&#125;)app.use(main) 11、释放 error 事件 123456789101112131415161718192021222324const handler = async (ctx, next) =&gt; &#123; try &#123; await next() &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500 ctx.response.type = 'html' ctx.response.body = '&lt;p&gt;有问题，请与管理员联系&lt;/p&gt;' // 释放error事件 ctx.app.emit('error', err, ctx) &#125;&#125;const main = (ctx) =&gt; &#123; ctx.throw(500)&#125;app.on('error', (err) =&gt; &#123; // 释放error事件后这里的监听函数才可生效 console.log('错误', err.message) console.log(err)&#125;)app.use(handler)app.use(main) 12、简单日志中间件例子 ./logger/koa-logger.js 1234module.exports = (ctx, next) =&gt; &#123; // 自定义 console.log(`$&#123;Date.now()&#125; $&#123;ctx.method&#125; $&#123;ctx.url&#125;`)&#125; ./logger.js 12const koaLogger = require('./logger/koa-logger')app.use(koaLogger) 13、简单异步中间件(必须写成 async 函数) 1npm install fs.promised 12345678const fs = require('fs.promised');const main = async (ctx, next) &#123; ctx.type = 'html'; ctx.body = await fs.readFile('./data/index.html', 'utf8');&#125;;app.use(main); 13、中间件合成例子 1npm install koa-compose 1234567891011121314const compose = require('koa-compose')const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.method&#125; $&#123;ctx.url&#125;`) next()&#125;const main = (ctx) =&gt; &#123; ctx.body = '主页'&#125;// 合成中间件const middlewares = compose([logger, main])app.use(middlewares) 14、读写 cookie 12345678910const main = (ctx) =&gt; &#123; // 读取cookie,没有返回0 const n = Number(ctx.cookies.get('view') || 0) + 1 // 设置cookie ctx.cookies.set('view', n) // 显示cookie ctx.response.body = n + ' views'&#125;app.use(main) 15、模拟表单 post 请求 1npm install koa-body 123456789101112const koaBody = require('koa-body')const main = async (ctx) =&gt; &#123; const body = ctx.body if (!body.name) &#123; ctx.throw(400, '.name required') &#125; ctx.body = &#123; name: body.name &#125;&#125;app.use(koaBody())app.use(main) 16、文件上传 123456789101112131415161718192021222324252627282930const koaBody = require('koa-body')const Router = require('koa-router')const fs = require('fs')const path = require('path')const router = new Router()// 解析多部分主体，默认falseapp.use( koaBody(&#123; multipart: true, formidable: &#123; maxFileSize: 200 * 1024 * 1024, // 设置上传文件大小最大限制，默认2M &#125;, &#125;))app.use(router.routes()).use(router.allowedMethods())// 上传单个文件router.post('/uploadfile', (ctx, next) =&gt; &#123; // 获取上传文件 const file = ctx.request.files.file // 创建可读流 const reader = fs.createReadStream(file.path) let filePath = path.join(__dirname, 'data/') + `/$&#123;file.name&#125;` // 创建可写流 const upStream = fs.createWriteStream(filePath) // 可读流通过管道写入可写流 reader.pipe(upStream) return (ctx.body = '上传成功！')&#125;) 17、简易连接 mysql 封装 1npm install --save mysql ./util/mysql.js 1234567891011121314151617181920212223242526272829303132// 引入mysql依赖const mysql = require('mysql')// 创建数据库连接池const pool = mysql.createPool(&#123; host: '127.0.0.1', // 数据库服务器地址 user: 'root', // 数据库用户名 password: '123456', // 数据库密码 database: 'test', // 连接的数据库&#125;)// 调用封装let query = async (sql, values) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; pool.getConnection((err, connection) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; connection.query(sql, values, (error, results, fields) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(results) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;module.exports = &#123; query,&#125; ./service/mysql.js 12345678910// 调用例子const &#123; query &#125; = require('../util/mysql.js')const queryUser = async (ctx) =&gt; &#123; return await query('SELECT username FROM t_user')&#125;module.exports = User = &#123; queryUser,&#125; 参考 koa","categories":[{"name":"Node","slug":"Node","permalink":"https://pengdon.github.io/categories/Node/"}],"tags":[{"name":"Koa","slug":"Koa","permalink":"https://pengdon.github.io/tags/Koa/"}]},{"title":"hexo 基础","slug":"hexo","date":"2020-04-29T01:54:54.000Z","updated":"2020-04-29T02:49:03.717Z","comments":true,"path":"2020/04/29/hexo/","link":"","permalink":"https://pengdon.github.io/2020/04/29/hexo/","excerpt":"","text":"前提 Node10^ git 什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 Hexo 1npm install -g hexo-cli 建站 1、 执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 2、 工程默认结构 12345678// Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去├── _config.yml // 网站的 配置 信息，您可以在此配置大部分的参数├── package.json // 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，也可以自由移除├── scaffolds // 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件├── source // 资源文件夹是存放用户资源的地方。| ├── _drafts // | └── _posts // 除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略└── themes // 主题 文件夹。Hexo 会根据主题来生成静态页面 _config.yml 配置 1、 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述，主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词 keywords 网站的关键词。使用半角逗号 , 分隔多个关键词。 author 您的名字，用于主题显示文章的作者 language 网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai 2、 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 pretty_urls 改写 permalink 的值来美化 URL pretty_urls.trailing_index 是否在永久链接中保留尾部的 index.html，设置为 false 时去除 true pretty_urls.trailing_html 是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效) true 网站存放在子目录,如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/ 1234# 比如，一个页面的永久链接是 http://example.com/foo/bar/index.htmlpretty_urls: trailing_index: false# 此时页面的永久链接会变为 http://example.com/foo/bar/ 3、目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹，source_dir 下的子目录 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。 12345skip_render: \"mypage/**/*\"# 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 'public' 目录# 你也可以用这种方法来跳过对指定文章文件的渲染skip_render: \"_posts/test-post.md\"# 这将会忽略对 'test-post.md' 的渲染 提示 如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。 4、文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true external_link.enable 在新标签中打开链接 true external_link.field 对整个网站（site）生效或仅对文章（post）生效 site external_link.exclude 需要排除的域名。主域名和子域名如 www 需分别配置 [] filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 highlight.enable 开启代码块高亮 true highlight.auto_detect 如果未指定语言，则启用自动检测 false highlight.line_number 显示行数 Enabling this option will also enable wrap option true highlight.tab_replace 用 n 个空格替换 tabs；如果值为空，则不会替换tabs ‘’ highlight.wrap Wrap the code block in table true highlight.hljs Use the hljs-* prefix for CSS classes false 相对地址 默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com,您有一篇文章名为 hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 5、分类&amp;标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 6、 日期 / 时间格式 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 HH:mm:ss use_date_for_updated 启用以后，如果 Front Matter 中没有指定 updated， post.updated 将会使用 date 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 true 7、分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 8、扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 theme_config 主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置 deploy 部署部分的设置 meta_generator Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签 9、包括或不包括目录和文件 在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 glob 表达式 对目录和文件进行匹配。 include and exclude options only apply to the source/ folder, whereas ignore option applies to all folders. 参数 描述 include Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。 exclude Hexo 会忽略这些文件和目录 ignore Ignore files/folders 12345678910111213141516171819202122232425262728293031# Include/Exclude Files/Foldersinclude: - \".nojekyll\" # 包括 'source/css/_typing.css' - \"css/_typing.css\" # 包括 'source/_css/' 中的任何文件，但不包括子目录及其其中的文件。 - \"_css/*\" # 包含 'source/_css/' 中的任何文件和子目录下的任何文件 - \"_css/**/*\"exclude: # 不包括 'source/js/test.js' - \"js/test.js\" # 不包括 'source/js/' 中的文件、但包括子目录下的所有目录和文件 - \"js/*\" # 不包括 'source/js/' 中的文件和子目录下的任何文件 - \"js/**/*\" # 不包括 'source/js/' 目录下的所有文件名以 'test' 开头的文件，但包括其它文件和子目录下的单文件 - \"js/test*\" # 不包括 'source/js/' 及其子目录中任何以 'test' 开头的文件 - \"js/**/test*\" # 不要用 exclude 来忽略 'source/_posts/' 中的文件。你应该使用 'skip_render'，或者在要忽略的文件的文件名之前加一个下划线 '_' # 在这里配置一个 - \"_posts/hello-world.md\" 是没有用的。ignore: # Ignore any folder named 'foo'. - \"**/foo\" # Ignore 'foo' folder in 'themes/' only. - \"**/themes/*/foo\" # Same as above, but applies to every subfolders of 'themes/'. - \"**/themes/**/foo\" 列表中的每一项都必须用单引号或双引号包裹起来。 include 和 exclude 并不适用于 themes/ 目录下的文件。如果需要忽略 themes/ 目录下的部分文件或文件夹，可以使用 ignore 或在文件名之前添加下划线 _。 使用代替配置文件 可以在 hexo-cli 中使用 --config 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如： 12345# use 'custom.yml' in place of '_config.yml'$ hexo server --config custom.yml# use 'custom.yml' &amp; 'custom2.json', prioritizing 'custom3.yml', then 'custom2.json'$ hexo generate --config custom.yml,custom2.json,custom3.yml 当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。 12# 例如，使用 --options 指定了两个自定义配置文件：hexo generate --config custom.yml,custom2.json 如果 custom.yml 中指定了 foo: bar，在 custom2.json 中指定了 “foo”: “dinosaur”，那么在 _multiconfig.yml 中你会得到 foo: dinosaur。 覆盖主题配置 通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 _config.yml 配置文件。 你可以在站点的 _config.yml 配置文件中配置你的主题，这样你就不需要 fork 一份主题并维护主题独立的配置文件。 以下是一个覆盖主题配置的例子： 123# _config.ymltheme_config: bio: \"My awesome bio\" 123# themes/my-theme/_config.ymlbio: \"Some generic bio\"logo: \"a-cool-image.png\" 最终主题配置的输出是： 1234&#123; bio: \"My awesome bio\", logo: \"a-cool-image.png\"&#125; 指令 命令 描述 hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 hexo new [layout] title 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来 hexo generate 生成静态文件(简写写：hexo g) hexo publish [layout] filename 发表草稿 hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/ hexo deploy 部署网站(简写：hexo d) hexo render file1 [file2] … 渲染文件 hexo migrate type 从其他博客系统 迁移内容。 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo list type 列出网站资料 hexo version 显示 Hexo 版本 hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 hexo --debug 在终端中显示调试信息并记录到 debug.log hexo --silent 简洁模式,隐藏终端信息 hexo --draft 显示 source/_drafts 文件夹中的草稿文章 hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径 自定义配置文件的路径 12345# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml 自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。 你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如： 12345# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml 当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。 参考 hexo","categories":[{"name":"blog","slug":"blog","permalink":"https://pengdon.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://pengdon.github.io/tags/hexo/"}]},{"title":"express基础","slug":"express","date":"2020-04-28T07:35:11.000Z","updated":"2020-04-29T03:12:54.464Z","comments":true,"path":"2020/04/28/express/","link":"","permalink":"https://pengdon.github.io/2020/04/28/express/","excerpt":"","text":"Express 是什么？ 官方概念：基于 Node.js 平台，快速、开放、极简的 Web 开发框架 优势 小巧灵活：Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能 易上手：express对web开发相关的模块进行了适度的封装，屏蔽了大量复杂繁琐的技术细节，让开发者只需要专注于业务逻辑的开发，极大的降低了入门和学习的成本 高性能：express仅在web应用相关的nodejs模块上进行了适度的封装和扩展，较大程度避免了过度封装导致的性能损耗 扩展性强：基于中间件的开发模式，使得express应用的扩展、模块拆分非常简单，既灵活，扩展性又强 怎么使用Express？ 1、安装express 1npm install express --save 2、代码最基本结构 12345678// 1、引入express模块const express = require('express')// 2、创建 express 实例const app = express()// 3、自定义路由， 响应HTTP的GET方法app.get('/', (req, res) =&gt; res.send('Hello World!'))// 4、监听3000端口请求app.listen(3000, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`)) 3、一个典型的使用express的app.js，主要做了以下几件事： 引入express模块 创建 express 实例 使用app.set设置express内部的一些参数(options) 使用app.use来注册函数 通过http.createServer用app来处理请求 使用场景 1、作为资源服务器 2、开发web项目 3、作为中间件提供服务 配置设置 express可以使用 set(setting,value)、 enable(setting)、disable(setting)方法来配置 下面是可以配置的变量： 名称 作用 默认值 env 定义环境模式字符串，如development,testing,production process.env.NODE_ENV trust proxy 启用/禁用反向代理的支持 false jsonp callback name 定义JSONP请求的默认回调名称 ?callback= json replacer 定义JSON replacer回调函数 null json spaces 指定当格式化JSON响应时使用的空格数量 开发中为2，在生产为0 case sensitive routing 启用/禁用区分大小写，如/home与/Home是不一样的 disabled strict routing 启用/禁用严格的路由，如/home和/home/是不一样的 disabled view cache 启用/禁用视图模板编译缓存 enabled view engine 指定呈现模板时，如果从视图中省略了文件扩展名，应该使用的默认模板引擎扩展 views 指定模板引擎用来查找视图模板的路径 ./views 配置路由 语法 12345app.get(path,[middleware],callback)app.post(path,[middleware],callback)// middleware是回调函数执行前要应用的中间件函数// callback是应该处理该请求并把响应发回给客户端的请求处理程序// callback以Request对象作为第一个参数，以Response对象作为第二个参数 全路径匹配 1234// 全部路径的全局处理程序app.all('*',function(req,res)&#123; &#125;); 无参数场景 12345678app.get('/',function(req,res)&#123; // 发送各种类型的响应 res.send(\"get\");&#125;);app.post('/',function(req,res)&#123; // 发送各种类型的响应 res.send(\"post\");&#125;); 有参数场景 123456app.get('/getUserInfo',function(req,res)&#123; let params = req.query; // get传递过来的参数 res.send(\"get params\"+params.id);&#125;);// eg: get 请求 /getUserInfo?id=u123// params.id -&gt; u123 正则匹配参数 12345app.get(/^\\/money\\/(\\w+)\\:(\\w+)?$/.function(req,res)&#123; res.send('get money ' + req.params[0] + req.params[1]);&#125;);// eg: get 请求 /money/10:66// req.params[0]-&gt;10 req.params[1]-&gt;66 已定义的参数 12345app.get('/user/:userid',function(req,res)&#123; res.send(\"Get User: \" + req.param(\"userid\"));&#125;);// eg: get 请求 /user/u123// req.param(\"userid\") -&gt; u123 已定义的参数应用回调函数 12// 这里的next是一个用于已注册的下一个app.param()回调的回调函数，必须要在回调函数中的某处调用next()，否则回调链会被破坏。value是从URL路径解析的参数的值。app.param(param,function(req,res,next,value)&#123;&#125;) Request对象 属性 名称 作用 originalUrl 请求的原始URL字符串 protocol 协议的字符串，如http或https ip 请求的ip地址 path 请求的路径部分 host 请求的主机名 method HTTP方法 query 请求的URL的查询字符串部分 fresh 一个布尔值，当最后修改与当前匹配时为true stale 一个布尔值，当最后修改与当前匹配时为false secure 一个布尔值，当建立TLS连接时为true acceptsCharset(charset) 一个方法，如果由charset指定的字符集受支持，返回true get(header) 返回header的值的方法 headers 请求标头的对象形式 Response对象 设置标头 名称 作用 get(header) 返回指定的header参数的值 set(header,value) 设置header参数的值 set(headerObj) 接受一个对象，包括多个’header’:'value’属性 locatio(path) 把location标头设置为指定的path参数 type(type_string) 根据type_string参数设置Content-Type标头 attachment([filepath]) 把Content-Disposition标头设置为attachment，并且如果指定filepath，则Content-Type头是基于文件扩展名设置的 设置状态 名称 作用 200 正确 300 Rediction重定向 400 Bad Request错误的请求 401 Unauthorized未经许可 403 Forbidden禁止 500 Server Error服务器错误 发送响应 res.send(status,[body]) body是一个String或者Buffer对象，如果指定Buffer对象，内容类型就被自动设置为application/octet-stream(应用程序/八位字节流) 发送JSON响应 res.json(status,[object]) 123456789app.get('/json',function(req,res)&#123; app.set('json spaces',4); res.json(&#123;name:'bob',built:'1223',centers:['art','maths']&#125;);&#125;);// jsonp callback name被设置为cb,意味着客户端需要在URL中传递的不是?callback=&lt;function&gt;，而是?cb=&lt;function&gt;app.get('jsonp',function(res,req)&#123; app.set('jsonp callback name','cb'); res.jsonp(&#123;name:'bob',built:'1223',centers:['art','maths']&#125;);&#125;); 发送文件 res.sendFile(path,[options],[callback]) 12345678910111213// path指向你要发送给客户端的文件，options参数是一个对象，// 包含了一个maxAge属性定义的最长期限和root属性(用来支持path参数相对路径的根路径)// 当文件传输完成时，回调函数被调用，并接受一个错误作为唯一的参数app.get('/image',function(req,res)&#123; res.sendFile('arch.jpg',&#123;maxAge:1,root:'./views'&#125;, function(err)&#123; if(err)&#123; console.log('Error'); &#125;else&#123; console.log('Success'); &#125; &#125;);&#125;); 发送下载响应 res.download(path,[filename],[callback]) 重定向响应 res.redirect(path); 中间件 Express提供的大部分功能是通过中间件函数完成的，这些中间件函数在nodejs收到请求的时点和发送响应的时点之间执行。Express的connect模块提供了中间件框架，让你方便的在全局或路径级别或为单个路由插入中间件功能。通过Express支持的中间件可以让你快速提供静态文件，实现cookie，支持会话，处理post数据等等，你甚至可以创建自己的自定义中间件函数，并利用它们来预处理请求和提供自己的功能。 有哪些中间件 名称 作用 static 允许Express服务器以流式处理静态文件的GET请求，这个中间件是Express内置的，它可以通过express.static()访问 express-logger 实现一个格式化的请求记录器来在跟踪对服务器的请求 basic-auth-connect 提供对基本的HTTP身份验证的支持 cookie-parser 可以从请求读取cookie并在响应中设置cookie cookie-session 提供基于cookie的会话支持 express-session 提供了一个强大的会话支持 body-parser 把POST请求正文中的JSON数据解析为req.body属性 compression 对发给客户端的大响应提供Gzip压缩支持 caurf 提供跨站点请求伪造保护 安装中间件 1npm install 中间名称 --save 分配中间件 1&gt; 在全局范围内把中间件分配给某个路径 12345678910// 要对所有路由指定中间件，可以在Express app对象上实现Use()方法：// use([path],middleware)// 其中，path是可选的，默认为/，意味着所有的路径，middleware是一个函数，// 即function(req,res,next)&#123;&#125;，每个中间件函数都有一个构造函数，它返回相应的中间件功能。// next是要执行的下一个中间件函数。// 例如，把body-parser中间件应用于所有路径：var express=require('express');var bodyParser=require('body-parser');var app=express();app.use('/',bodyParser()); 2&gt; 把中间件分配到单个路由 123456var express=require('express');var bodyParser=require('body-parser');var app=express();app.get('/parseRoute',bodyParser(),function(req,res)&#123; // coding&#125;); 3&gt; 添加多个中间件函数 12345678// 可以根据需要在全局范围和路由上分配任意多的中间件函数var express=require('express');var bodyParser=require('body-parser');var cookieParser=require)('cookie-parser');var session=require('express-session');var app=express();// 注意，你分配函数的顺序就是它们在请求中被应用的顺序。一些中间件需要被添加在别的中间件函数前面。app.use('/',bodyParser()).use('/',cookieParser()).use('/',session()); 常见问题 如何处理 404 响应？ 123app.use(function (req, res, next) &#123; res.status(404).send(\"Sorry can't find that!\")&#125;) 如何设置一个错误处理器？ 1234app.use(function (err, req, res, next) &#123; console.error(err.stack) res.status(500).send('Something broke!')&#125;) 如何渲染纯 HTML 文件？ 1234// 可以通过 res.sendFile() 直接对外输出 HTML 文件res.readFile('index.html')// 如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件app.use(express.static('htmls')); 参考 Express","categories":[{"name":"Node","slug":"Node","permalink":"https://pengdon.github.io/categories/Node/"}],"tags":[{"name":"Express","slug":"Express","permalink":"https://pengdon.github.io/tags/Express/"}]},{"title":"node开发环境配置","slug":"node","date":"2020-04-28T06:57:46.000Z","updated":"2020-04-28T07:22:29.248Z","comments":true,"path":"2020/04/28/node/","link":"","permalink":"https://pengdon.github.io/2020/04/28/node/","excerpt":"","text":"前置条件 1、开发软件安装目录 d:\\dev node下载与安装 1、node官方下载地址：https://nodejs.org/en/download/ 2、安装node时选择自定义目录，例如：d:\\dev\\node 系统环境变量配置(win10) 1、修改当前用户下的系统变量path，添加node目录：d:\\dev\\node 2、在命令窗口执行node -v、npm -v,查看安装是否成功 node配置 1、在d:\\dev\\node目录下新建两个文件夹，分别是node_global(全局包下载存放目录)和node_cache(node缓存) 2、执行命令，更改配置 12npm config set prefix \"d:\\dev\\node\\node_global\"npm config set cache \"d:\\dev\\node\\node_cache\" 3、查看配置文件内容 12# 用命令查看npm config ls 4、修改当前用户下的系统变量path，添加d:\\dev\\node\\node_global 5、在当前用户下新增系统变量，变量名：NODE_PATH 变量值：d:\\dev\\node\\node_global\\node_modules 切换到淘宝镜像 1npm config set registry https://registry.npm.taobao.org","categories":[{"name":"Node","slug":"Node","permalink":"https://pengdon.github.io/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://pengdon.github.io/tags/Node/"},{"name":"Npm","slug":"Npm","permalink":"https://pengdon.github.io/tags/Npm/"}]},{"title":"vue-cli2.0版本 prerender 预渲染","slug":"prerender2","date":"2020-04-28T03:26:07.000Z","updated":"2020-04-28T03:47:29.335Z","comments":true,"path":"2020/04/28/prerender2/","link":"","permalink":"https://pengdon.github.io/2020/04/28/prerender2/","excerpt":"","text":"前提 node10^ 、 npm6^ 、vue-cli3 简写 -S --&gt; --save // 生产阶段的依赖 -D --&gt; --save-dev // 开发阶段的依赖 预渲染 1、先用手脚架创建个项目 1234vue init webpack vue2-prerendercd vue2-prerendernpm installnpm run dev 2、项目大致结构如下： 1234567891011121314151617-vue2-prerender--build--config--node_modules--src--static--test--.babelrc--.editorconfig--.eslintignore--.eslintrc.js--.gitignore--.postcssrc.js--index.html--package.json--package-lock.json--readme.md 3、预渲染插件安装 12# 设置镜像下载可以加速下载npm config set PUPPETEER_DOWNLOAD_HOST=https://npm.taobao.org/mirrors &amp;&amp; npm install prerender-spa-plugin -D 4、修改build目录下的webpack.prod.conf.js文件 12345678910111213// 1、引入依赖const PrerenderSpaPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSpaPlugin.PuppeteerRenderer// 2、配置插件,在plugins数组里面添加预渲染插件new PrerenderSpaPlugin(&#123; staticDir: path.join(__dirname, '../dist'), routes: ['/', '/about'], renderer: new Renderer(&#123; inject: &#123;&#125;, headless: false, renderAfterDocumentEvent: 'render-event' &#125;)&#125;) 5、修改mian.js文件，内容如下： 12345678910111213141516import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = falsenew Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;', mounted () &#123; // 这句非常重要，否则预渲染将不会启动 document.dispatchEvent(new Event('render-event')) &#125;&#125;) 6、修改router目录的index.js文件 1234567export default new Router(&#123; mode: 'history', // 预渲染一定要模式改成history routes, scrollBehavior (to, from, savedPosition) &#123; return &#123; x: 0, y: 0 &#125; &#125;&#125;) 7、 执行构建打包命令 1npm run build 8、 可以看到根目录多了个dist文件夹，目录结构如下： 12345-dist--about--static--favicon.ico--index.html","categories":[{"name":"Vue","slug":"Vue","permalink":"https://pengdon.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"prerender-spa-plugin","slug":"prerender-spa-plugin","permalink":"https://pengdon.github.io/tags/prerender-spa-plugin/"},{"name":"seo","slug":"seo","permalink":"https://pengdon.github.io/tags/seo/"}]},{"title":"vue-cli3.0版本 prerender 预渲染","slug":"prerender","date":"2020-04-28T03:01:27.000Z","updated":"2020-04-28T03:33:41.232Z","comments":true,"path":"2020/04/28/prerender/","link":"","permalink":"https://pengdon.github.io/2020/04/28/prerender/","excerpt":"","text":"前提 node10^ 、 npm6^ 、vue-cli3 简写 -S --&gt; --save // 生产阶段的依赖 -D --&gt; --save-dev // 开发阶段的依赖 普通场景下的预渲染 1、利用手脚架新建个项目 1234vue create vue3-prerendercd vue3-prerendernpm installnpm run serve 2、项目大致结构如下： 1234567891011121314vue3-prerender--node_modules--public--src--tests--.browserslistrc--.editorconfig--.eslintrc.js--.gitignore--babel.config.js--jest.config.js--package.json--package-lock.json--README.md 3、运行项目 12npm run serve# 可以看到有两个视图Home、About 4、预渲染插件安装 12# 设置镜像下载可以加速下载npm config set PUPPETEER_DOWNLOAD_HOST=https://npm.taobao.org/mirrors &amp;&amp; npm install prerender-spa-plugin -D 5、新建vue.config.js文件配置预渲染,文件内容如下： 1234567891011121314151617181920212223242526// 普通场景下的预渲染const path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123; publicPath:'/', configureWebpack:config=&gt;&#123; // 生产环境 if (process.env.NODE_ENV === 'production') &#123; // 预渲染配置 new PrerenderSPAPlugin(&#123; // 默认输出是dist目录 staticDir: path.join(__dirname, 'dist'), // 必需，要渲染的路线，根据自己定义的路由配置 routes: ['/', '/about'], // 必须，要使用的实际渲染器，没有则不能预编译 renderer: new Renderer(&#123; inject: &#123;&#125;, headless: false, // 渲染时显示浏览器窗口。对调试很有用。 renderAfterDocumentEvent: 'render-event' &#125;) &#125;) &#125; &#125;&#125; 6、修改main.js文件,修改后内容如下： 1234567891011121314import Vue from 'vue'import App from './App.vue'import router from './router'Vue.config.productionTip = falsenew Vue(&#123; router, render: h =&gt; h(App), mounted () &#123; // 这句非常重要，否则预渲染将不会启动 document.dispatchEvent(new Event('render-event')) &#125;&#125;).$mount('#app') 7、修改router目录下的index.js文件，修改内容如下： 12345678910111213141516171819202122232425import Vue from 'vue'import VueRouter from 'vue-router'import Home from '@/views/Home.vue'Vue.use(VueRouter)const routes = [ &#123; path: '/', name: 'Home', component: Home &#125;, &#123; path: '/about', name: 'About', component: () =&gt; import('../views/About.vue') &#125;]const router = new VueRouter(&#123; mode: 'history', // 预渲染一定要模式改成history routes&#125;)export default router 8、 执行构建打包命令 1npm run build 9、 可以看到根目录多了个dist文件夹，目录结构如下： 12345-dist--about--static--favicon.ico--index.html 在vue.config.js的预渲染插件路由数组里面配置了几个路由就会生成相应的静态文件 特殊场景下的预渲染 场景描述 1、例如公司主域名是 www.abc.com，现在开发的项目是挂载在主域名下的子目录，也就是通过https://www.abc.com/edu访问 2、由于目前路由是history模式，子目录的场景需要改路由的base属性、vue.config.js的publicPath属性，影响到预渲染的其他配置 具体操作针对普通场景配置做修改 1、修改router目录下的index.js文件，内容如下： 1234567891011121314151617181920212223242526import Vue from 'vue'import VueRouter from 'vue-router'import Home from '@/views/Home.vue'Vue.use(VueRouter)const routes = [ &#123; path: '/', name: 'Home', component: Home &#125;, &#123; path: '/about', name: 'About', component: () =&gt; import('../views/About.vue') &#125;]const router = new VueRouter(&#123; mode: 'history', // 预渲染一定要模式改成history base: '/edu/', // 这个根据实际场景自己配置，但要与vue.config.js文件中的publicPath属性保持一致 routes&#125;)export default router 2、修改vue.config.js文件，内容如下： 12345678910111213141516171819202122232425262728// 普通场景下的预渲染const path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123; publicPath: process.env.NODE_ENV === 'production'?'/edu/':'/', outputDir: 'dist/edu', configureWebpack:config=&gt;&#123; // 生产环境 if (process.env.NODE_ENV === 'production') &#123; // 预渲染配置 new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, 'dist/'), outputDir: path.join(__dirname, 'dist/edu'), indexPath: path.join(__dirname, 'dist', '/edu/index.html'), // 必需，要渲染的路线，根据自己定义的路由配置 routes: ['/', '/about'], // 必须，要使用的实际渲染器，没有则不能预编译 renderer: new Renderer(&#123; inject: &#123;&#125;, headless: false, // 渲染时显示浏览器窗口。对调试很有用。 renderAfterDocumentEvent: 'render-event' &#125;) &#125;) &#125; &#125;&#125; 3、 执行构建打包命令 1npm run build 4、 可以看到根目录多了个dist文件夹，目录结构如下： 123456-dist--edu---about---static---favicon.ico---index.html 常见问题以及解决方案 问题1：项目打包发布到服务器上后，刷新页面会出现404问题 原因 路由是history模式导致的 解决方案 修改服务器相关nginx.conf配置 12345678location ~* ^/edu &#123; try_files $uri $uri/ /index.html; # 解决vue路由history模式打包到生产，刷新页面出现404的问题 index index.html index.htm; if ( !-e $request_filename ) &#123; rewrite ^(.*) /edu/index.html; break; &#125;&#125; 相关参考 Vue Vue CLI Webpack4^ webpack-chain puppeteer prerender-spa-plugin","categories":[{"name":"Vue","slug":"Vue","permalink":"https://pengdon.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"prerender-spa-plugin","slug":"prerender-spa-plugin","permalink":"https://pengdon.github.io/tags/prerender-spa-plugin/"},{"name":"seo","slug":"seo","permalink":"https://pengdon.github.io/tags/seo/"}]},{"title":"算法学习笔记1","slug":"arithmetic","date":"2020-04-27T01:23:56.950Z","updated":"2020-06-12T05:59:54.554Z","comments":true,"path":"2020/04/27/arithmetic/","link":"","permalink":"https://pengdon.github.io/2020/04/27/arithmetic/","excerpt":"","text":"为什么学习算法？ 算法的影响力是宽广和深远的。影响的领域不完全列表如下: 网络。包括搜索，包路由，分布式共享文件。 生物。包括基因工程，蛋白质折叠。 计算机。电路草图，文件系统，编译器。 计算机图形图像。电影，电子游戏，虚拟现实。 安全。手机，电子商务，投票计算机。 多媒体。mp3，jpg，divx，hdtv，人脸识别。 社会网络。推荐系统，新闻feeding，广告学。 物理学。n体模拟，粒子碰撞模拟。 什么是算法？ 算法的定义：解决特定问题的求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 程序 = 数据结构 + 算法 数据结构：把现实世界中的问题信息化，将信息存入计算机。(要处理的信息) 算法：处理这些信息，以解决实际问题。(处理信息的步骤) 算法的特性 输入。丢给算法处理的数据 输出。算法处理的结果 有穷性。有穷时间内能执行完(1.算法是有穷的 2.程序可以是无穷的) 确定性。相同输入只会产生相同输出 可行性。可用已有的基本操作实现算法 算法的要求 正确性。能正确解决问题 可读性。对算法的描述要让其他人也看得懂 健壮性。算法能处理一些异常情况 时间效率高和存储量低。(1.算法执行省时，省内存 2.时间复杂度低，空间复杂度低) 算法效率度量方法 事后统计方法（不科学、不准确） 事前分析估算方法 在分析程序的运行时间时，最重要的是把程序看成独立于程序设计语言的算法或一系列步骤。 算法的渐近增长 函数的渐近增长（概念）：给定两个函数 f(n) 和 g(n)，如果存在一个整数N，使得对于所有的 n&gt;N, f(n) 总是比 g(n) 大，那么我们说 f(n) 的增长渐近快于 g(n) 。 （我的理解）就是给两个函数，n表示他们的规模，但n大于某一个值的时候，一个函数的值总是比另一个函数的大，那么我们可以理解这个函数渐近增长较快。 算法的时间复杂度（重点、难点） 算法的时间复杂度定义：在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模n的函数，进而分析 T(n) 随n的变化情况并确定 T(n) 的数量级。算法的时间复杂度（算法的时间量度）记作 T(n) = O（f(n)）。表示随着问题规模n的增长，算法执行的时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。其中 f(n) 是问题规模n的某个函数。 大O阶方法 用常数1取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不为1，则去除与这个项相乘的常数，得到的结果就是大O阶，即时间复杂度。 常见的时间复杂度所消耗时间的大小 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 时间复杂度 时间复杂度小结 时间复杂度是用来估计算法运行时间的一个式子(单位)。 一般来说，时间复杂度高的算法比复杂度低的算法慢。 常见的时间复杂度（按效率排序） O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n2logn) &lt; O(n3) 复杂问题的时间复杂度 O(n!) O(2n) O(nn) … 简单快速判断算法的时间复杂度(适用大多数简单场景) 确定问题规模n 循环减半过程→logn k层关于n的循环→nk 复杂情况：根据算法执⾏行行过程判断 空间复杂度 空间复杂度：用来评估算法内存占用大小的式子 (空间换时间) 空间复杂度的表示方式与时间复杂度完全一样 算法使用了有限变量：O(1) 算法使用了长度为n的一维列表：O(n) 算法使用了m行n列的二维列表：O(mn)","categories":[{"name":"Arithmetic","slug":"Arithmetic","permalink":"https://pengdon.github.io/categories/Arithmetic/"}],"tags":[]},{"title":"nextjs+typescript","slug":"nextjs","date":"2019-11-14T12:11:27.000Z","updated":"2020-04-28T01:41:32.897Z","comments":true,"path":"2019/11/14/nextjs/","link":"","permalink":"https://pengdon.github.io/2019/11/14/nextjs/","excerpt":"","text":"基础 1. 先创建一个最基础的Nextjs项目 12345mkdir next-tscd next-tsnpm init -ynpm install --save react react-dom nextmkdir pages 2. 添加Typescipt和@types相关依赖 1npm install --save-dev typescript @types/react @types/node 3. 修改next-ts目录下package.json文件中scripts属性的内容 12345\"scripts\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\"&#125; 4. 在pages目录下创建index.tsx文件，文件内容如下： 12const Home = () =&gt; &lt;h1&gt;Nextjs typescript!&lt;/h1&gt;;export default Home; 5. 启动dev server查看效果 1npm run dev","categories":[{"name":"React-SSR","slug":"React-SSR","permalink":"https://pengdon.github.io/categories/React-SSR/"}],"tags":[{"name":"nextjs","slug":"nextjs","permalink":"https://pengdon.github.io/tags/nextjs/"}]},{"title":"vue-ssr基本用法","slug":"vueSsr1","date":"2019-11-14T12:11:27.000Z","updated":"2020-04-28T06:18:04.158Z","comments":true,"path":"2019/11/14/vueSsr1/","link":"","permalink":"https://pengdon.github.io/2019/11/14/vueSsr1/","excerpt":"","text":"基础 1. 先创建一个最基础的Nextjs项目 1234mkdir vue-srr-democd vue-srr-demonpm init -ynpm install vue vue-server-renderer --save 2. 创建一个app.js文件,内容如下： 123456789const Vue = require('vue')module.exports = function createApp (context) &#123; return new Vue(&#123; data: &#123; url: context.url &#125;, template: `&lt;div&gt;Vue SSR URL: &#123;&#123; url &#125;&#125;&lt;/div&gt;` &#125;)&#125; 3. 与服务器集成 1npm install express --save 4. 创建一个server.js文件,内容如下： 1234567const server = require('express')()server.get('/ssr', (request, response) =&gt; &#123; response.send(\"当前访问URL \"+request.url)&#125;)server.listen(8000) 5. 创建一个页面模板index.html,内容如下： 1234567&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt; 6. 修改server.js文件，内容如下： 1234567891011121314const server = require('express')()const createApp = require('./app')const renderer = require('vue-server-renderer').createRenderer()server.get('/ssr', (request, response) =&gt; &#123; const context = &#123; url: request.url &#125; const app = createApp(context) renderer.renderToString(app, (err, doc) =&gt; &#123; if (err) throw err response.send(doc) &#125;)&#125;)server.listen(8000) 7. 启动服务查看效果 123node server.js# 或者安装nodemon自动重启插件[npm install -g nodemon]nodemon server.js 8. 在浏览器访问：http://localhost:8000/ssr 1Vue SSR URL: /ssr 9. 模板插值，修改index.html 123456789101112&lt;html&gt;&lt;head&gt; &lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt; &#123;&#123;&#123; meta &#125;&#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt; 10. 修改server.js文件，内容如下： 123456789101112131415161718192021222324const server = require('express')()const createApp = require('./app')const renderer = require('vue-server-renderer').createRenderer(&#123; template: require('fs').readFileSync('./index.html', 'utf-8')&#125;)server.get('/ssr', (request, response) =&gt; &#123; const context = &#123; url: request.url, title: 'vue-ssr', meta: ` &lt;meta ...&gt; &lt;meta ...&gt; ` &#125; const app = createApp(context) renderer.renderToString(app, context, (err, doc) =&gt; &#123; if (err) throw err response.send(doc) &#125;)&#125;)server.listen(8000) 11. 启动服务，查看网页源代码，发现title和meta标签成功插入 123node server.js# 或者安装nodemon自动重启插件[npm install -g nodemon]nodemon server.js","categories":[{"name":"Vue-SSR","slug":"Vue-SSR","permalink":"https://pengdon.github.io/categories/Vue-SSR/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"}]}]}