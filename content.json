{"meta":{"title":"pengdon","subtitle":null,"description":null,"author":"don","url":"https://pengdon.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-11-14T11:25:53.000Z","updated":"2020-04-28T01:40:55.616Z","comments":false,"path":"about/index.html","permalink":"https://pengdon.github.io/about/index.html","excerpt":"","text":"​ On the way, it’s coming, it’s coming"},{"title":"categories","date":"2019-11-14T11:31:42.000Z","updated":"2020-04-27T01:23:56.956Z","comments":false,"path":"categories/index.html","permalink":"https://pengdon.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-14T11:39:03.000Z","updated":"2020-04-27T01:23:56.958Z","comments":false,"path":"tags/index.html","permalink":"https://pengdon.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"express基础","slug":"express","date":"2020-04-28T07:35:11.000Z","updated":"2020-04-28T10:51:43.422Z","comments":true,"path":"2020/04/28/express/","link":"","permalink":"https://pengdon.github.io/2020/04/28/express/","excerpt":"","text":"Express 是什么？ 官方概念：基于 Node.js 平台，快速、开放、极简的 Web 开发框架 优势 小巧灵活：Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能 易上手：express对web开发相关的模块进行了适度的封装，屏蔽了大量复杂繁琐的技术细节，让开发者只需要专注于业务逻辑的开发，极大的降低了入门和学习的成本 高性能：express仅在web应用相关的nodejs模块上进行了适度的封装和扩展，较大程度避免了过度封装导致的性能损耗 扩展性强：基于中间件的开发模式，使得express应用的扩展、模块拆分非常简单，既灵活，扩展性又强 怎么使用Express？ 1、安装express 1npm install express --save 2、代码最基本结构 12345678// 1、引入express模块const express = require('express')// 2、创建 express 实例const app = express()// 3、自定义路由， 响应HTTP的GET方法app.get('/', (req, res) =&gt; res.send('Hello World!'))// 4、监听3000端口请求app.listen(3000, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`)) 3、一个典型的使用express的app.js，主要做了以下几件事： 引入express模块 创建 express 实例 使用app.set设置express内部的一些参数(options) 使用app.use来注册函数 通过http.createServer用app来处理请求 使用场景 1、作为资源服务器 2、开发web项目 3、作为中间件提供服务 配置设置 express可以使用 set(setting,value)、 enable(setting)、disable(setting)方法来配置 下面是可以配置的变量： 名称 作用 默认值 env 定义环境模式字符串，如development,testing,production process.env.NODE_ENV trust proxy 启用/禁用反向代理的支持 false jsonp callback name 定义JSONP请求的默认回调名称 ?callback= json replacer 定义JSON replacer回调函数 null json spaces 指定当格式化JSON响应时使用的空格数量 开发中为2，在生产为0 case sensitive routing 启用/禁用区分大小写，如/home与/Home是不一样的 disabled strict routing 启用/禁用严格的路由，如/home和/home/是不一样的 disabled view cache 启用/禁用视图模板编译缓存 enabled view engine 指定呈现模板时，如果从视图中省略了文件扩展名，应该使用的默认模板引擎扩展 views 指定模板引擎用来查找视图模板的路径 ./views 配置路由 语法 12345app.get(path,[middleware],callback)app.post(path,[middleware],callback)// middleware是回调函数执行前要应用的中间件函数// callback是应该处理该请求并把响应发回给客户端的请求处理程序// callback以Request对象作为第一个参数，以Response对象作为第二个参数 全路径匹配 1234// 全部路径的全局处理程序app.all('*',function(req,res)&#123; &#125;); 无参数场景 12345678app.get('/',function(req,res)&#123; // 发送各种类型的响应 res.send(\"get\");&#125;);app.post('/',function(req,res)&#123; // 发送各种类型的响应 res.send(\"post\");&#125;); 有参数场景 123456app.get('/getUserInfo',function(req,res)&#123; let params = req.query; // get传递过来的参数 res.send(\"get params\"+params.id);&#125;);// eg: get 请求 /getUserInfo?id=u123// params.id -&gt; u123 正则匹配参数 12345app.get(/^\\/money\\/(\\w+)\\:(\\w+)?$/.function(req,res)&#123; res.send('get money ' + req.params[0] + req.params[1]);&#125;);// eg: get 请求 /money/10:66// req.params[0]-&gt;10 req.params[1]-&gt;66 已定义的参数 12345app.get('/user/:userid',function(req,res)&#123; res.send(\"Get User: \" + req.param(\"userid\"));&#125;);// eg: get 请求 /user/u123// req.param(\"userid\") -&gt; u123 已定义的参数应用回调函数 12// 这里的next是一个用于已注册的下一个app.param()回调的回调函数，必须要在回调函数中的某处调用next()，否则回调链会被破坏。value是从URL路径解析的参数的值。app.param(param,function(req,res,next,value)&#123;&#125;) Request对象 属性 名称 作用 originalUrl 请求的原始URL字符串 protocol 协议的字符串，如http或https ip 请求的ip地址 path 请求的路径部分 host 请求的主机名 method HTTP方法 query 请求的URL的查询字符串部分 fresh 一个布尔值，当最后修改与当前匹配时为true stale 一个布尔值，当最后修改与当前匹配时为false secure 一个布尔值，当建立TLS连接时为true acceptsCharset(charset) 一个方法，如果由charset指定的字符集受支持，返回true get(header) 返回header的值的方法 headers 请求标头的对象形式 Response对象 设置标头 名称 作用 get(header) 返回指定的header参数的值 set(header,value) 设置header参数的值 set(headerObj) 接受一个对象，包括多个’header’:'value’属性 locatio(path) 把location标头设置为指定的path参数 type(type_string) 根据type_string参数设置Content-Type标头 attachment([filepath]) 把Content-Disposition标头设置为attachment，并且如果指定filepath，则Content-Type头是基于文件扩展名设置的 设置状态 名称 作用 200 正确 300 Rediction重定向 400 Bad Request错误的请求 401 Unauthorized未经许可 403 Forbidden禁止 500 Server Error服务器错误 发送响应 res.send(status,[body]) body是一个String或者Buffer对象，如果指定Buffer对象，内容类型就被自动设置为application/octet-stream(应用程序/八位字节流) 发送JSON响应 res.json(status,[object]) 123456789app.get('/json',function(req,res)&#123; app.set('json spaces',4); res.json(&#123;name:'bob',built:'1223',centers:['art','maths']&#125;);&#125;);// jsonp callback name被设置为cb,意味着客户端需要在URL中传递的不是?callback=&lt;function&gt;，而是?cb=&lt;function&gt;app.get('jsonp',function(res,req)&#123; app.set('jsonp callback name','cb'); res.jsonp(&#123;name:'bob',built:'1223',centers:['art','maths']&#125;);&#125;); 发送文件 res.sendFile(path,[options],[callback]) 12345678910111213// path指向你要发送给客户端的文件，options参数是一个对象，// 包含了一个maxAge属性定义的最长期限和root属性(用来支持path参数相对路径的根路径)// 当文件传输完成时，回调函数被调用，并接受一个错误作为唯一的参数app.get('/image',function(req,res)&#123; res.sendFile('arch.jpg',&#123;maxAge:1,root:'./views'&#125;, function(err)&#123; if(err)&#123; console.log('Error'); &#125;else&#123; console.log('Success'); &#125; &#125;);&#125;); 发送下载响应 res.download(path,[filename],[callback]) 重定向响应 res.redirect(path); 中间件 Express提供的大部分功能是通过中间件函数完成的，这些中间件函数在nodejs收到请求的时点和发送响应的时点之间执行。Express的connect模块提供了中间件框架，让你方便的在全局或路径级别或为单个路由插入中间件功能。通过Express支持的中间件可以让你快速提供静态文件，实现cookie，支持会话，处理post数据等等，你甚至可以创建自己的自定义中间件函数，并利用它们来预处理请求和提供自己的功能。 有哪些中间件 名称 作用 static 允许Express服务器以流式处理静态文件的GET请求，这个中间件是Express内置的，它可以通过express.static()访问 express-logger 实现一个格式化的请求记录器来在跟踪对服务器的请求 basic-auth-connect 提供对基本的HTTP身份验证的支持 cookie-parser 可以从请求读取cookie并在响应中设置cookie cookie-session 提供基于cookie的会话支持 express-session 提供了一个强大的会话支持 body-parser 把POST请求正文中的JSON数据解析为req.body属性 compression 对发给客户端的大响应提供Gzip压缩支持 caurf 提供跨站点请求伪造保护 安装中间件 1npm install 中间名称 --save 分配中间件 1&gt; 在全局范围内把中间件分配给某个路径 12345678910// 要对所有路由指定中间件，可以在Express app对象上实现Use()方法：// use([path],middleware)// 其中，path是可选的，默认为/，意味着所有的路径，middleware是一个函数，// 即function(req,res,next)&#123;&#125;，每个中间件函数都有一个构造函数，它返回相应的中间件功能。// next是要执行的下一个中间件函数。// 例如，把body-parser中间件应用于所有路径：var express=require('express');var bodyParser=require('body-parser');var app=express();app.use('/',bodyParser()); 2&gt; 把中间件分配到单个路由 123456var express=require('express');var bodyParser=require('body-parser');var app=express();app.get('/parseRoute',bodyParser(),function(req,res)&#123; // coding&#125;); 3&gt; 添加多个中间件函数 12345678// 可以根据需要在全局范围和路由上分配任意多的中间件函数var express=require('express');var bodyParser=require('body-parser');var cookieParser=require)('cookie-parser');var session=require('express-session');var app=express();// 注意，你分配函数的顺序就是它们在请求中被应用的顺序。一些中间件需要被添加在别的中间件函数前面。app.use('/',bodyParser()).use('/',cookieParser()).use('/',session()); 常见问题 如何处理 404 响应？ 123app.use(function (req, res, next) &#123; res.status(404).send(\"Sorry can't find that!\")&#125;) 如何设置一个错误处理器？ 1234app.use(function (err, req, res, next) &#123; console.error(err.stack) res.status(500).send('Something broke!')&#125;) 如何渲染纯 HTML 文件？ 1234// 可以通过 res.sendFile() 直接对外输出 HTML 文件res.readFile('index.html')// 如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件app.use(express.static('htmls')); 参考 Express","categories":[{"name":"Node","slug":"Node","permalink":"https://pengdon.github.io/categories/Node/"}],"tags":[{"name":"Express","slug":"Express","permalink":"https://pengdon.github.io/tags/Express/"},{"name":"Node","slug":"Node","permalink":"https://pengdon.github.io/tags/Node/"}]},{"title":"node开发环境配置","slug":"node","date":"2020-04-28T06:57:46.000Z","updated":"2020-04-28T07:22:29.248Z","comments":true,"path":"2020/04/28/node/","link":"","permalink":"https://pengdon.github.io/2020/04/28/node/","excerpt":"","text":"前置条件 1、开发软件安装目录 d:\\dev node下载与安装 1、node官方下载地址：https://nodejs.org/en/download/ 2、安装node时选择自定义目录，例如：d:\\dev\\node 系统环境变量配置(win10) 1、修改当前用户下的系统变量path，添加node目录：d:\\dev\\node 2、在命令窗口执行node -v、npm -v,查看安装是否成功 node配置 1、在d:\\dev\\node目录下新建两个文件夹，分别是node_global(全局包下载存放目录)和node_cache(node缓存) 2、执行命令，更改配置 12npm config set prefix \"d:\\dev\\node\\node_global\"npm config set cache \"d:\\dev\\node\\node_cache\" 3、查看配置文件内容 12# 用命令查看npm config ls 4、修改当前用户下的系统变量path，添加d:\\dev\\node\\node_global 5、在当前用户下新增系统变量，变量名：NODE_PATH 变量值：d:\\dev\\node\\node_global\\node_modules 切换到淘宝镜像 1npm config set registry https://registry.npm.taobao.org","categories":[{"name":"Node","slug":"Node","permalink":"https://pengdon.github.io/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://pengdon.github.io/tags/Node/"},{"name":"Npm","slug":"Npm","permalink":"https://pengdon.github.io/tags/Npm/"}]},{"title":"vue-cli2.0版本 prerender 预渲染","slug":"prerender2","date":"2020-04-28T03:26:07.000Z","updated":"2020-04-28T03:47:29.335Z","comments":true,"path":"2020/04/28/prerender2/","link":"","permalink":"https://pengdon.github.io/2020/04/28/prerender2/","excerpt":"","text":"前提 node10^ 、 npm6^ 、vue-cli3 简写 -S --&gt; --save // 生产阶段的依赖 -D --&gt; --save-dev // 开发阶段的依赖 预渲染 1、先用手脚架创建个项目 1234vue init webpack vue2-prerendercd vue2-prerendernpm installnpm run dev 2、项目大致结构如下： 1234567891011121314151617-vue2-prerender--build--config--node_modules--src--static--test--.babelrc--.editorconfig--.eslintignore--.eslintrc.js--.gitignore--.postcssrc.js--index.html--package.json--package-lock.json--readme.md 3、预渲染插件安装 12# 设置镜像下载可以加速下载npm config set PUPPETEER_DOWNLOAD_HOST=https://npm.taobao.org/mirrors &amp;&amp; npm install prerender-spa-plugin -D 4、修改build目录下的webpack.prod.conf.js文件 12345678910111213// 1、引入依赖const PrerenderSpaPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSpaPlugin.PuppeteerRenderer// 2、配置插件,在plugins数组里面添加预渲染插件new PrerenderSpaPlugin(&#123; staticDir: path.join(__dirname, '../dist'), routes: ['/', '/about'], renderer: new Renderer(&#123; inject: &#123;&#125;, headless: false, renderAfterDocumentEvent: 'render-event' &#125;)&#125;) 5、修改mian.js文件，内容如下： 12345678910111213141516import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = falsenew Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;', mounted () &#123; // 这句非常重要，否则预渲染将不会启动 document.dispatchEvent(new Event('render-event')) &#125;&#125;) 6、修改router目录的index.js文件 1234567export default new Router(&#123; mode: 'history', // 预渲染一定要模式改成history routes, scrollBehavior (to, from, savedPosition) &#123; return &#123; x: 0, y: 0 &#125; &#125;&#125;) 7、 执行构建打包命令 1npm run build 8、 可以看到根目录多了个dist文件夹，目录结构如下： 12345-dist--about--static--favicon.ico--index.html","categories":[{"name":"Vue","slug":"Vue","permalink":"https://pengdon.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"prerender-spa-plugin","slug":"prerender-spa-plugin","permalink":"https://pengdon.github.io/tags/prerender-spa-plugin/"},{"name":"seo","slug":"seo","permalink":"https://pengdon.github.io/tags/seo/"}]},{"title":"vue-cli3.0版本 prerender 预渲染","slug":"prerender","date":"2020-04-28T03:01:27.000Z","updated":"2020-04-28T03:33:41.232Z","comments":true,"path":"2020/04/28/prerender/","link":"","permalink":"https://pengdon.github.io/2020/04/28/prerender/","excerpt":"","text":"前提 node10^ 、 npm6^ 、vue-cli3 简写 -S --&gt; --save // 生产阶段的依赖 -D --&gt; --save-dev // 开发阶段的依赖 普通场景下的预渲染 1、利用手脚架新建个项目 1234vue create vue3-prerendercd vue3-prerendernpm installnpm run serve 2、项目大致结构如下： 1234567891011121314vue3-prerender--node_modules--public--src--tests--.browserslistrc--.editorconfig--.eslintrc.js--.gitignore--babel.config.js--jest.config.js--package.json--package-lock.json--README.md 3、运行项目 12npm run serve# 可以看到有两个视图Home、About 4、预渲染插件安装 12# 设置镜像下载可以加速下载npm config set PUPPETEER_DOWNLOAD_HOST=https://npm.taobao.org/mirrors &amp;&amp; npm install prerender-spa-plugin -D 5、新建vue.config.js文件配置预渲染,文件内容如下： 1234567891011121314151617181920212223242526// 普通场景下的预渲染const path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123; publicPath:'/', configureWebpack:config=&gt;&#123; // 生产环境 if (process.env.NODE_ENV === 'production') &#123; // 预渲染配置 new PrerenderSPAPlugin(&#123; // 默认输出是dist目录 staticDir: path.join(__dirname, 'dist'), // 必需，要渲染的路线，根据自己定义的路由配置 routes: ['/', '/about'], // 必须，要使用的实际渲染器，没有则不能预编译 renderer: new Renderer(&#123; inject: &#123;&#125;, headless: false, // 渲染时显示浏览器窗口。对调试很有用。 renderAfterDocumentEvent: 'render-event' &#125;) &#125;) &#125; &#125;&#125; 6、修改main.js文件,修改后内容如下： 1234567891011121314import Vue from 'vue'import App from './App.vue'import router from './router'Vue.config.productionTip = falsenew Vue(&#123; router, render: h =&gt; h(App), mounted () &#123; // 这句非常重要，否则预渲染将不会启动 document.dispatchEvent(new Event('render-event')) &#125;&#125;).$mount('#app') 7、修改router目录下的index.js文件，修改内容如下： 12345678910111213141516171819202122232425import Vue from 'vue'import VueRouter from 'vue-router'import Home from '@/views/Home.vue'Vue.use(VueRouter)const routes = [ &#123; path: '/', name: 'Home', component: Home &#125;, &#123; path: '/about', name: 'About', component: () =&gt; import('../views/About.vue') &#125;]const router = new VueRouter(&#123; mode: 'history', // 预渲染一定要模式改成history routes&#125;)export default router 8、 执行构建打包命令 1npm run build 9、 可以看到根目录多了个dist文件夹，目录结构如下： 12345-dist--about--static--favicon.ico--index.html 在vue.config.js的预渲染插件路由数组里面配置了几个路由就会生成相应的静态文件 特殊场景下的预渲染 场景描述 1、例如公司主域名是 www.abc.com，现在开发的项目是挂载在主域名下的子目录，也就是通过https://www.abc.com/edu访问 2、由于目前路由是history模式，子目录的场景需要改路由的base属性、vue.config.js的publicPath属性，影响到预渲染的其他配置 具体操作针对普通场景配置做修改 1、修改router目录下的index.js文件，内容如下： 1234567891011121314151617181920212223242526import Vue from 'vue'import VueRouter from 'vue-router'import Home from '@/views/Home.vue'Vue.use(VueRouter)const routes = [ &#123; path: '/', name: 'Home', component: Home &#125;, &#123; path: '/about', name: 'About', component: () =&gt; import('../views/About.vue') &#125;]const router = new VueRouter(&#123; mode: 'history', // 预渲染一定要模式改成history base: '/edu/', // 这个根据实际场景自己配置，但要与vue.config.js文件中的publicPath属性保持一致 routes&#125;)export default router 2、修改vue.config.js文件，内容如下： 12345678910111213141516171819202122232425262728// 普通场景下的预渲染const path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123; publicPath: process.env.NODE_ENV === 'production'?'/edu/':'/', outputDir: 'dist/edu', configureWebpack:config=&gt;&#123; // 生产环境 if (process.env.NODE_ENV === 'production') &#123; // 预渲染配置 new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, 'dist/'), outputDir: path.join(__dirname, 'dist/edu'), indexPath: path.join(__dirname, 'dist', '/edu/index.html'), // 必需，要渲染的路线，根据自己定义的路由配置 routes: ['/', '/about'], // 必须，要使用的实际渲染器，没有则不能预编译 renderer: new Renderer(&#123; inject: &#123;&#125;, headless: false, // 渲染时显示浏览器窗口。对调试很有用。 renderAfterDocumentEvent: 'render-event' &#125;) &#125;) &#125; &#125;&#125; 3、 执行构建打包命令 1npm run build 4、 可以看到根目录多了个dist文件夹，目录结构如下： 123456-dist--edu---about---static---favicon.ico---index.html 常见问题以及解决方案 问题1：项目打包发布到服务器上后，刷新页面会出现404问题 原因 路由是history模式导致的 解决方案 修改服务器相关nginx.conf配置 12345678location ~* ^/edu &#123; try_files $uri $uri/ /index.html; # 解决vue路由history模式打包到生产，刷新页面出现404的问题 index index.html index.htm; if ( !-e $request_filename ) &#123; rewrite ^(.*) /edu/index.html; break; &#125;&#125; 相关参考 Vue Vue CLI Webpack4^ webpack-chain puppeteer prerender-spa-plugin","categories":[{"name":"Vue","slug":"Vue","permalink":"https://pengdon.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"prerender-spa-plugin","slug":"prerender-spa-plugin","permalink":"https://pengdon.github.io/tags/prerender-spa-plugin/"},{"name":"seo","slug":"seo","permalink":"https://pengdon.github.io/tags/seo/"}]},{"title":"JavaScript算法1","slug":"arithmetic","date":"2020-04-27T01:23:56.950Z","updated":"2020-04-28T06:56:32.415Z","comments":true,"path":"2020/04/27/arithmetic/","link":"","permalink":"https://pengdon.github.io/2020/04/27/arithmetic/","excerpt":"","text":"1. 输出没有连续重复字符的组合数 问题描述：把一个字符串中的所有的字符重新排列，然后生成一个新的字符串，返回的新字符串中没有连续重复的字符。连续重复是以单个字符为判断标准。 例如：aab应该返回 2， 因为它总共有 6 种排列方式： aab， aab， aba， aba， baa， baa，但是其中只有 2 个没有连续重复的字符（字符 a 是本例中的重复字符）：aba，aba 预期结果： permAlone(“aab”)应该返回 2。 permAlone(“aaa”)应该返回 0。 permAlone(“aabb”)应该返回 8。 permAlone(“abcdefa”)应该返回 3600。 permAlone(“abfdefa”)应该返回 2640。 permAlone(“aaab”)应该返回 0。 123456789101112131415161718192021222324function permAlone(str) &#123; // 匹配是否有重复字符 let reg = /(\\w)\\1+/g; if (str.match(reg) !== null &amp;&amp; str.match(reg)[0] === str) return 0; let arr = str.split(''); // 利用es6解构赋值交换元素位置 function swap(n1,n2)&#123; [arr[n1],arr[n2]] = [arr[n2],arr[n1]] &#125; let tempArr = []; function generate(len)&#123; if(len === 1 &amp;&amp; !arr.join('').match(reg))&#123; tempArr.push(arr.join('')) &#125;else&#123; for(let i = 0; i!=len;++i)&#123; generate(len-1); swap(len%2?0:i,len-1) &#125; &#125; &#125; generate(arr.length) // 利用filter去重返回新数组 return tempArr.length;&#125; 2. 输出对等分差 问题描述：两个集合的对称差分是只属于其中一个集合，而不属于另一个集合的元素组成的集合，例如：集合let A = [ 1, 2, 3]和let B = [ 2, 3, 4]的对称差分为A △ B = C = [ 1, 4]。 集合论中的这个运算相当于布尔逻辑中的异或运算。 设定两个数组 (例如：let A = [1, 2, 3]，let B = [2, 3, 4])作为参数传入，返回对称差分数组（A △ B = C = [1, 4]），且数组中没有重复项。 预期结果： sym([1, 2, 3, 3], [5, 2, 1, 4])应该返回[3, 4, 5]。 sym([1, 2, 3], [5, 2, 1, 4, 5])应该返回[3, 4, 5]。 sym([1, 2, 5], [2, 3, 5], [3, 4, 5])应该返回[1, 4, 5]。 sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])应该返回[1, 4, 5]。 sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3])应该返回[2, 3, 4, 6, 7]。 sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1])应该返回[1, 2, 4, 5, 6, 7, 8, 9]。 1234567891011function sym(...args) &#123; // 利用reduce组合数据，再利用Set去重 return [...new Set(args.reduce(diffArray))].sort();&#125;// 区分两个数组,返回不同部分function diffArray(arr1, arr2) &#123; return arr1 .filter(element =&gt; !arr2.includes(element)) .concat(arr2.filter(element =&gt; !arr1.includes(element)));&#125;","categories":[{"name":"Arithmetic","slug":"Arithmetic","permalink":"https://pengdon.github.io/categories/Arithmetic/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://pengdon.github.io/tags/Javascript/"}]},{"title":"nextjs+typescript","slug":"nextjs","date":"2019-11-14T12:11:27.000Z","updated":"2020-04-28T01:41:32.897Z","comments":true,"path":"2019/11/14/nextjs/","link":"","permalink":"https://pengdon.github.io/2019/11/14/nextjs/","excerpt":"","text":"基础 1. 先创建一个最基础的Nextjs项目 12345mkdir next-tscd next-tsnpm init -ynpm install --save react react-dom nextmkdir pages 2. 添加Typescipt和@types相关依赖 1npm install --save-dev typescript @types/react @types/node 3. 修改next-ts目录下package.json文件中scripts属性的内容 12345\"scripts\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\"&#125; 4. 在pages目录下创建index.tsx文件，文件内容如下： 12const Home = () =&gt; &lt;h1&gt;Nextjs typescript!&lt;/h1&gt;;export default Home; 5. 启动dev server查看效果 1npm run dev","categories":[{"name":"React-SSR","slug":"React-SSR","permalink":"https://pengdon.github.io/categories/React-SSR/"}],"tags":[{"name":"nextjs","slug":"nextjs","permalink":"https://pengdon.github.io/tags/nextjs/"}]},{"title":"vue-ssr基本用法","slug":"vueSsr1","date":"2019-11-14T12:11:27.000Z","updated":"2020-04-28T06:18:04.158Z","comments":true,"path":"2019/11/14/vueSsr1/","link":"","permalink":"https://pengdon.github.io/2019/11/14/vueSsr1/","excerpt":"","text":"基础 1. 先创建一个最基础的Nextjs项目 1234mkdir vue-srr-democd vue-srr-demonpm init -ynpm install vue vue-server-renderer --save 2. 创建一个app.js文件,内容如下： 123456789const Vue = require('vue')module.exports = function createApp (context) &#123; return new Vue(&#123; data: &#123; url: context.url &#125;, template: `&lt;div&gt;Vue SSR URL: &#123;&#123; url &#125;&#125;&lt;/div&gt;` &#125;)&#125; 3. 与服务器集成 1npm install express --save 4. 创建一个server.js文件,内容如下： 1234567const server = require('express')()server.get('/ssr', (request, response) =&gt; &#123; response.send(\"当前访问URL \"+request.url)&#125;)server.listen(8000) 5. 创建一个页面模板index.html,内容如下： 1234567&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt; 6. 修改server.js文件，内容如下： 1234567891011121314const server = require('express')()const createApp = require('./app')const renderer = require('vue-server-renderer').createRenderer()server.get('/ssr', (request, response) =&gt; &#123; const context = &#123; url: request.url &#125; const app = createApp(context) renderer.renderToString(app, (err, doc) =&gt; &#123; if (err) throw err response.send(doc) &#125;)&#125;)server.listen(8000) 7. 启动服务查看效果 123node server.js# 或者安装nodemon自动重启插件[npm install -g nodemon]nodemon server.js 8. 在浏览器访问：http://localhost:8000/ssr 1Vue SSR URL: /ssr 9. 模板插值，修改index.html 123456789101112&lt;html&gt;&lt;head&gt; &lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt; &#123;&#123;&#123; meta &#125;&#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt; 10. 修改server.js文件，内容如下： 123456789101112131415161718192021222324const server = require('express')()const createApp = require('./app')const renderer = require('vue-server-renderer').createRenderer(&#123; template: require('fs').readFileSync('./index.html', 'utf-8')&#125;)server.get('/ssr', (request, response) =&gt; &#123; const context = &#123; url: request.url, title: 'vue-ssr', meta: ` &lt;meta ...&gt; &lt;meta ...&gt; ` &#125; const app = createApp(context) renderer.renderToString(app, context, (err, doc) =&gt; &#123; if (err) throw err response.send(doc) &#125;)&#125;)server.listen(8000) 11. 启动服务，查看网页源代码，发现title和meta标签成功插入 123node server.js# 或者安装nodemon自动重启插件[npm install -g nodemon]nodemon server.js","categories":[{"name":"Vue-SSR","slug":"Vue-SSR","permalink":"https://pengdon.github.io/categories/Vue-SSR/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"}]}]}