{"meta":{"title":"pengdon","subtitle":null,"description":null,"author":"don","url":"https://pengdon.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-11-14T11:25:53.000Z","updated":"2020-04-28T01:40:55.616Z","comments":false,"path":"about/index.html","permalink":"https://pengdon.github.io/about/index.html","excerpt":"","text":"​ On the way, it’s coming, it’s coming"},{"title":"tags","date":"2019-11-14T11:39:03.000Z","updated":"2020-04-27T01:23:56.958Z","comments":false,"path":"tags/index.html","permalink":"https://pengdon.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-11-14T11:31:42.000Z","updated":"2020-04-27T01:23:56.956Z","comments":false,"path":"categories/index.html","permalink":"https://pengdon.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript算法","slug":"index","date":"2020-04-27T01:23:56.950Z","updated":"2020-04-27T01:23:56.950Z","comments":true,"path":"2020/04/27/index/","link":"","permalink":"https://pengdon.github.io/2020/04/27/index/","excerpt":"","text":"1. 输出没有连续重复字符的组合数 问题描述：把一个字符串中的所有的字符重新排列，然后生成一个新的字符串，返回的新字符串中没有连续重复的字符。连续重复是以单个字符为判断标准。 例如：aab应该返回 2， 因为它总共有 6 种排列方式： aab， aab， aba， aba， baa， baa，但是其中只有 2 个没有连续重复的字符（字符 a 是本例中的重复字符）：aba，aba 预期结果： permAlone(“aab”)应该返回 2。 permAlone(“aaa”)应该返回 0。 permAlone(“aabb”)应该返回 8。 permAlone(“abcdefa”)应该返回 3600。 permAlone(“abfdefa”)应该返回 2640。 permAlone(“aaab”)应该返回 0。 123456789101112131415161718192021222324function permAlone(str) &#123; // 匹配是否有重复字符 let reg = /(\\w)\\1+/g; if (str.match(reg) !== null &amp;&amp; str.match(reg)[0] === str) return 0; let arr = str.split(''); // 利用es6解构赋值交换元素位置 function swap(n1,n2)&#123; [arr[n1],arr[n2]] = [arr[n2],arr[n1]] &#125; let tempArr = []; function generate(len)&#123; if(len === 1 &amp;&amp; !arr.join('').match(reg))&#123; tempArr.push(arr.join('')) &#125;else&#123; for(let i = 0; i!=len;++i)&#123; generate(len-1); swap(len%2?0:i,len-1) &#125; &#125; &#125; generate(arr.length) // 利用filter去重返回新数组 return tempArr.length;&#125; 2. 输出对等分差 问题描述：两个集合的对称差分是只属于其中一个集合，而不属于另一个集合的元素组成的集合，例如：集合let A = [ 1, 2, 3]和let B = [ 2, 3, 4]的对称差分为A △ B = C = [ 1, 4]。 集合论中的这个运算相当于布尔逻辑中的异或运算。 设定两个数组 (例如：let A = [1, 2, 3]，let B = [2, 3, 4])作为参数传入，返回对称差分数组（A △ B = C = [1, 4]），且数组中没有重复项。 预期结果： sym([1, 2, 3, 3], [5, 2, 1, 4])应该返回[3, 4, 5]。 sym([1, 2, 3], [5, 2, 1, 4, 5])应该返回[3, 4, 5]。 sym([1, 2, 5], [2, 3, 5], [3, 4, 5])应该返回[1, 4, 5]。 sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])应该返回[1, 4, 5]。 sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3])应该返回[2, 3, 4, 6, 7]。 sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1])应该返回[1, 2, 4, 5, 6, 7, 8, 9]。 1234567891011function sym(...args) &#123; // 利用reduce组合数据，再利用Set去重 return [...new Set(args.reduce(diffArray))].sort();&#125;// 区分两个数组,返回不同部分function diffArray(arr1, arr2) &#123; return arr1 .filter(element =&gt; !arr2.includes(element)) .concat(arr2.filter(element =&gt; !arr1.includes(element)));&#125;","categories":[{"name":"Arithmetic","slug":"Arithmetic","permalink":"https://pengdon.github.io/categories/Arithmetic/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://pengdon.github.io/tags/Javascript/"}]},{"title":"vue-cli3.0版本 prerender 预渲染","slug":"prerender","date":"2019-11-14T12:11:27.000Z","updated":"2020-04-28T03:04:36.261Z","comments":true,"path":"2019/11/14/prerender/","link":"","permalink":"https://pengdon.github.io/2019/11/14/prerender/","excerpt":"","text":"前提 node10^ 、 npm6^ 、vue-cli3 简写 -S --&gt; --save // 生产阶段的依赖 -D --&gt; --save-dev // 开发阶段的依赖 普通场景下的预渲染 1、利用手脚架新建个项目 12vue create vue3-prerendercd vue3-prerender 2、项目大致结构如下： 1234567891011121314vue3-prerender--node_modules--public--src--tests--.browserslistrc--.editorconfig--.eslintrc.js--.gitignore--babel.config.js--jest.config.js--package.json--package-lock.json--README.md 3、运行项目 12npm run serve# 可以看到有两个视图Home、About 4、预渲染插件安装 12# 设置镜像下载可以加速下载npm config set PUPPETEER_DOWNLOAD_HOST=https://npm.taobao.org/mirrors &amp;&amp; npm install prerender-spa-plugin -D 5、新建vue.config.js文件配置预渲染,文件内容如下： 1234567891011121314151617181920212223242526// 普通场景下的预渲染const path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123; publicPath:'/', configureWebpack:config=&gt;&#123; // 生产环境 if (process.env.NODE_ENV === 'production') &#123; // 预渲染配置 new PrerenderSPAPlugin(&#123; // 默认输出是dist目录 staticDir: path.join(__dirname, 'dist'), // 必需，要渲染的路线，根据自己定义的路由配置 routes: ['/', '/about'], // 必须，要使用的实际渲染器，没有则不能预编译 renderer: new Renderer(&#123; inject: &#123;&#125;, headless: false, // 渲染时显示浏览器窗口。对调试很有用。 renderAfterDocumentEvent: 'render-event' &#125;) &#125;) &#125; &#125;&#125; 6、修改main.js文件,修改后内容如下： 1234567891011121314import Vue from 'vue'import App from './App.vue'import router from './router'Vue.config.productionTip = falsenew Vue(&#123; router, render: h =&gt; h(App), mounted () &#123; // 这句非常重要，否则预渲染将不会启动 document.dispatchEvent(new Event('render-event')) &#125;&#125;).$mount('#app') 7、修改router目录下的index.js文件，修改内容如下： 12345678910111213141516171819202122232425import Vue from 'vue'import VueRouter from 'vue-router'import Home from '@/views/Home.vue'Vue.use(VueRouter)const routes = [ &#123; path: '/', name: 'Home', component: Home &#125;, &#123; path: '/about', name: 'About', component: () =&gt; import('../views/About.vue') &#125;]const router = new VueRouter(&#123; mode: 'history', // 预渲染一定要模式改成history routes&#125;)export default router 8、 执行构建打包命令 1npm run build 9、 可以看到根目录多了个dist文件夹，目录结构如下： 12345-dist--about--static--favicon.ico--index.html 在vue.config.js的预渲染插件路由数组里面配置了几个路由就会生成相应的静态文件 特殊场景下的预渲染 场景描述 1、例如公司主域名是 www.abc.com，现在开发的项目是挂载在主域名下的子目录，也就是通过https://www.abc.com/edu访问 2、由于目前路由是history模式，子目录的场景需要改路由的base属性、vue.config.js的publicPath属性，影响到预渲染的其他配置 具体操作针对普通场景配置做修改 1、修改router目录下的index.js文件，内容如下： 1234567891011121314151617181920212223242526import Vue from 'vue'import VueRouter from 'vue-router'import Home from '@/views/Home.vue'Vue.use(VueRouter)const routes = [ &#123; path: '/', name: 'Home', component: Home &#125;, &#123; path: '/about', name: 'About', component: () =&gt; import('../views/About.vue') &#125;]const router = new VueRouter(&#123; mode: 'history', // 预渲染一定要模式改成history base: '/edu/', // 这个根据实际场景自己配置，但要与vue.config.js文件中的publicPath属性保持一致 routes&#125;)export default router 2、修改vue.config.js文件，内容如下： 12345678910111213141516171819202122232425262728// 普通场景下的预渲染const path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123; publicPath: process.env.NODE_ENV === 'production'?'/edu/':'/', outputDir: 'dist/edu', configureWebpack:config=&gt;&#123; // 生产环境 if (process.env.NODE_ENV === 'production') &#123; // 预渲染配置 new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, 'dist/'), outputDir: path.join(__dirname, 'dist/edu'), indexPath: path.join(__dirname, 'dist', '/edu/index.html'), // 必需，要渲染的路线，根据自己定义的路由配置 routes: ['/', '/about'], // 必须，要使用的实际渲染器，没有则不能预编译 renderer: new Renderer(&#123; inject: &#123;&#125;, headless: false, // 渲染时显示浏览器窗口。对调试很有用。 renderAfterDocumentEvent: 'render-event' &#125;) &#125;) &#125; &#125;&#125; 3、 执行构建打包命令 1npm run build 4、 可以看到根目录多了个dist文件夹，目录结构如下： 123456-dist--edu---about---static---favicon.ico---index.html 常见问题以及解决方案 问题1：项目打包发布到服务器上后，刷新页面会出现404问题 原因 路由是history模式导致的 解决方案 修改服务器相关nginx.conf配置 12345678location ~* ^/edu &#123; try_files $uri $uri/ /index.html; # 解决vue路由history模式打包到生产，刷新页面出现404的问题 index index.html index.htm; if ( !-e $request_filename ) &#123; rewrite ^(.*) /edu/index.html; break; &#125;&#125; 相关参考 Vue Vue CLI Webpack4^ webpack-chain puppeteer prerender-spa-plugin","categories":[{"name":"Vue-SSR","slug":"Vue-SSR","permalink":"https://pengdon.github.io/categories/Vue-SSR/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"},{"name":"prerender-spa-plugin","slug":"prerender-spa-plugin","permalink":"https://pengdon.github.io/tags/prerender-spa-plugin/"},{"name":"seo","slug":"seo","permalink":"https://pengdon.github.io/tags/seo/"}]},{"title":"vue-ssr基本用法","slug":"vueSsr1","date":"2019-11-14T12:11:27.000Z","updated":"2020-04-28T01:41:31.598Z","comments":true,"path":"2019/11/14/vueSsr1/","link":"","permalink":"https://pengdon.github.io/2019/11/14/vueSsr1/","excerpt":"","text":"基础 1. 先创建一个最基础的Nextjs项目 1234mkdir vue-srr-democd vue-srr-demonpm init -ynpm install vue vue-server-renderer --save 2. 创建一个app.js文件,内容如下： 123456789const Vue = require('vue')module.exports = function createApp (context) &#123; return new Vue(&#123; data: &#123; url: context.url &#125;, template: `&lt;div&gt;Vue SSR URL: &#123;&#123; url &#125;&#125;&lt;/div&gt;` &#125;)&#125; 2. 与服务器集成 1npm install express --save 3. 创建一个server.js文件,内容如下： 1234567const server = require('express')()server.get('/ssr', (request, response) =&gt; &#123; response.send(\"当前访问URL \"+request.url)&#125;)server.listen(8000) 4. 创建一个页面模板index.html,内容如下： 1234567&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt; 5. 修改server.js文件，内容如下： 1234567891011121314const server = require('express')()const createApp = require('./app')const renderer = require('vue-server-renderer').createRenderer()server.get('/ssr', (request, response) =&gt; &#123; const context = &#123; url: request.url &#125; const app = createApp(context) renderer.renderToString(app, (err, doc) =&gt; &#123; if (err) throw err response.send(doc) &#125;)&#125;)server.listen(8000) 6. 启动服务查看效果 123node server.js# 或者安装nodemon自动重启插件[npm install -g nodemon]nodemon server.js 7. 在浏览器访问：http://localhost:8000/ssr 1Vue SSR URL: /ssr 8. 模板插值，修改index.html 123456789101112&lt;html&gt;&lt;head&gt; &lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt; &#123;&#123;&#123; meta &#125;&#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt; 9. 修改server.js文件，内容如下： 123456789101112131415161718192021222324const server = require('express')()const createApp = require('./app')const renderer = require('vue-server-renderer').createRenderer(&#123; template: require('fs').readFileSync('./index.html', 'utf-8')&#125;)server.get('/ssr', (request, response) =&gt; &#123; const context = &#123; url: request.url, title: 'vue-ssr', meta: ` &lt;meta ...&gt; &lt;meta ...&gt; ` &#125; const app = createApp(context) renderer.renderToString(app, context, (err, doc) =&gt; &#123; if (err) throw err response.send(doc) &#125;)&#125;)server.listen(8000) 10. 启动服务，查看网页源代码，发现title和meta标签成功插入 123node server.js# 或者安装nodemon自动重启插件[npm install -g nodemon]nodemon server.js","categories":[{"name":"Vue-SSR","slug":"Vue-SSR","permalink":"https://pengdon.github.io/categories/Vue-SSR/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://pengdon.github.io/tags/vue/"}]},{"title":"nextjs+typescript","slug":"nextjs","date":"2019-11-14T12:11:27.000Z","updated":"2020-04-28T01:41:32.897Z","comments":true,"path":"2019/11/14/nextjs/","link":"","permalink":"https://pengdon.github.io/2019/11/14/nextjs/","excerpt":"","text":"基础 1. 先创建一个最基础的Nextjs项目 12345mkdir next-tscd next-tsnpm init -ynpm install --save react react-dom nextmkdir pages 2. 添加Typescipt和@types相关依赖 1npm install --save-dev typescript @types/react @types/node 3. 修改next-ts目录下package.json文件中scripts属性的内容 12345\"scripts\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\"&#125; 4. 在pages目录下创建index.tsx文件，文件内容如下： 12const Home = () =&gt; &lt;h1&gt;Nextjs typescript!&lt;/h1&gt;;export default Home; 5. 启动dev server查看效果 1npm run dev","categories":[{"name":"React-SSR","slug":"React-SSR","permalink":"https://pengdon.github.io/categories/React-SSR/"}],"tags":[{"name":"nextjs","slug":"nextjs","permalink":"https://pengdon.github.io/tags/nextjs/"}]}]}