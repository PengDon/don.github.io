<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>pengdon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pengdon.github.io/"/>
  <updated>2019-11-14T09:59:55.831Z</updated>
  <id>https://pengdon.github.io/</id>
  
  <author>
    <name>don</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript算法复习</title>
    <link href="https://pengdon.github.io/2019/11/12/index/"/>
    <id>https://pengdon.github.io/2019/11/12/index/</id>
    <published>2019-11-12T05:33:14.477Z</published>
    <updated>2019-11-14T09:59:55.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h3 id="1-输出没有连续重复字符的组合数"><a class="markdownIt-Anchor" href="#1-输出没有连续重复字符的组合数"></a> 1. 输出没有连续重复字符的组合数</h3><blockquote><p><strong>问题描述</strong>：把一个字符串中的所有的字符重新排列，然后生成一个新的字符串，返回的新字符串中没有连续重复的字符。连续重复是以单个字符为判断标准。<br />例如：aab应该返回 2， 因为它总共有 6 种排列方式： aab， aab， aba， aba， baa， baa，但是其中只有 2 个没有连续重复的字符（字符 a 是本例中的重复字符）：aba，aba</p></blockquote><blockquote><p><strong>预期结果</strong>：<br />permAlone(“aab”)应该返回 2。<br />permAlone(“aaa”)应该返回 0。<br />permAlone(“aabb”)应该返回 8。<br />permAlone(“abcdefa”)应该返回 3600。<br />permAlone(“abfdefa”)应该返回 2640。<br />permAlone(“aaab”)应该返回 0。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> permAlone(str) &#123;</span><br><span class="line">    // 匹配是否有重复字符</span><br><span class="line">    <span class="built_in">let</span> reg = /(\w)\1+/g;</span><br><span class="line">    <span class="keyword">if</span> (str.match(reg) !== null &amp;&amp; str.match(reg)[0] === str) <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="built_in">let</span> arr = str.split(<span class="string">''</span>);</span><br><span class="line">    // 利用es6解构赋值交换元素位置</span><br><span class="line">    <span class="keyword">function</span> swap(n1,n2)&#123;</span><br><span class="line">        [arr[n1],arr[n2]] = [arr[n2],arr[n1]]</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">let</span> tempArr = [];</span><br><span class="line">    <span class="keyword">function</span> generate(len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(len === 1)&#123;</span><br><span class="line">            tempArr.push(arr.join(<span class="string">''</span>))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i!=len;++i)&#123;</span><br><span class="line">                generate(len-1);</span><br><span class="line">                swap(len%2?0:i,len-1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    generate(arr.length) </span><br><span class="line">    // 利用filter去重返回新数组</span><br><span class="line">    <span class="built_in">return</span> tempArr.filter(v=&gt;!v.match(reg)).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-输出对等分差"><a class="markdownIt-Anchor" href="#2-输出对等分差"></a> 2. 输出对等分差</h3><blockquote><p><strong>问题描述</strong>：两个集合的对称差分是只属于其中一个集合，而不属于另一个集合的元素组成的集合，例如：集合let A = [ 1, 2, 3]和let B = [ 2, 3, 4]的对称差分为A △ B = C = [ 1, 4]。 集合论中的这个运算相当于布尔逻辑中的异或运算。<br />设定两个数组 (例如：let A = [1, 2, 3]，let B = [2, 3, 4])作为参数传入，返回对称差分数组（A △ B = C = [1, 4]），且数组中没有重复项。</p></blockquote><blockquote><p><strong>预期结果</strong>：<br />sym([1, 2, 3, 3], [5, 2, 1, 4])应该返回[3, 4, 5]。<br />sym([1, 2, 3], [5, 2, 1, 4, 5])应该返回[3, 4, 5]。<br />sym([1, 2, 5], [2, 3, 5], [3, 4, 5])应该返回[1, 4, 5]。<br />sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])应该返回[1, 4, 5]。<br />sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3])应该返回[2, 3, 4, 6, 7]。<br />sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1])应该返回[1, 2, 4, 5, 6, 7, 8, 9]。</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sym(...args) &#123;</span><br><span class="line">    // 利用reduce组合数据，再利用Set去重</span><br><span class="line">    <span class="built_in">return</span> [...new Set(args.reduce(diffArray))].sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 区分两个数组,返回不同部分</span><br><span class="line"><span class="keyword">function</span> diffArray(arr1, arr2) &#123;</span><br><span class="line">    var newArr = [];</span><br><span class="line">    arr1.forEach((v,i) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr2.indexOf(v)===-1)&#123;</span><br><span class="line">          newArr.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    arr2.forEach((v,i) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr1.indexOf(v)===-1)&#123;</span><br><span class="line">          newArr.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;h3 id=&quot;1-输出没有连续重复字符的组合数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-输出没有连续重复字符的组合数&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://pengdon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="https://pengdon.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
